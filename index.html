<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="images/favicon.png" rel="icon" type="image/png" />
    <title>Oraclize Documentation</title>

    <style>
      #logoc {
        text-align: center;
        left: 0;
        right: 0;
        margin: auto;
      }
      #logoMAIN {
        padding: 10px;
        text-align: center;
        left: 0;
        right: 0;
        margin: auto;
      }
      #logoText {
        text-align: center;
        left: 0;
        right: 0;
        margin: auto;
        color: #FFF;
        font-size: 1.75em;
      }
      #lastupdate {
	position: fixed;
	bottom: 10px;
	font-size: 1.13em;
        background-color: #393939;
	/*font-style: italic;*/
      }
      #chat {
        display: none;
        position: fixed;
        bottom: 10px;
        right: 20px;
        z-index: 10;
      }
      .extratitle {
        font-size: 30px;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;javascript&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <div id="logoc">
      <img src="images/logo.png" alt="Oraclize log" id="logoMAIN" width="100px">
      </div>
        <div class="lang-selector">
              <a href="#" data-language-name="javascript"></a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='https://github.com/oraclize/docs/wiki' target='_blank'>Suggest an edit</a></li>
            <li><a href='https://gitter.im/oraclize/' target='_blank'>Join the Oraclize Dev Community</a></li>
            <li><span id='lastupdate'></span></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        
          <h1 id="home">Home</h1>

<p>Welcome to the Documentation of Oraclize!</p>

<p>The documentation is divided in the following sections:</p>

<ul>
<li><a href="#background">Background</a>: the rationale behind the Oraclize&rsquo;s Oracle Model</li>
<li><a href="#general-concepts">General Concepts</a>: the main concepts behind Oraclize </li>
<li><a href="#data-source">Data-Sources</a>:  information regarding the types of data sources Oraclize supports</li>
<li><a href="#integrations">Integrations</a>: how to integrate a blockchain application with Oraclize</li>
<li><a href="#development-tools">Development Tools</a>: a list of tools to aide development of Oraclize-integrated smart contracts</li>
<li><a href="#security-deep-dive">Security Deep Dive</a>: how Oraclize&rsquo;s Authenticity proofs works </li>
<li><a href="#pricing">Pricing</a>: information on our pricing model for production uses </li>
</ul>

          <h1 id="background">Background</h1>

<p>Oraclize is the leading oracle service for smart contracts and blockchain applications, serving thousands of requests for day every day on Ethereum, Bitcoin and Rootstock.</p>

<p>In the blockchain space, an oracle is a party which provides data. The need for such figure arise from the fact that blockchain applications, such as Bitcoin scripts and smart contracts cannot access and fetch directly the data they require: price feeds for assets and financial applications; weather-related informations for peer-to-peer insurance; random number generation for gambling. </p>

<p>But to rely on a new trusted intermidiary, the oracle in this case, it would be betraying the security and reduced-trust model of blockchain applications: which is what makes them interesting and useful in first place. </p>

<p>One solution is to accept data inputs from more than one untrusted or partially trusted party and then execute the data-dependant action only after a number of them have provided the same answer or an answer within some constrains. This type of system can be considered a decentralized oracle system. Unfortunately, this approach has severe limitations:</p>

<ul>
<li>It requires a predefined standard on data format </li>
<li>It is inherently inefficient: all the parties participating will require a fee and, for every request, it will take time before reaching a sufficient number of answers. </li>
</ul>

<p>The solution developed by Oraclize is instead to demonstrate that the data fetched from the original data-source is genuine and untampered. This is accomplished by accompanying the returned data together with a document called authenticity proof. The authenticity proofs can build upon different technologies such as auditable virtual machines and Trusted Execution Environments. </p>

<p>A more detailed overview of Oraclize authenticity proofs is provided in the <a href="#Authenticity Proof">Authenticity Proofs</a> section of this documentation.</p>

<p>This solutions elegantly solves the Oracle Problem:</p>

<ul>
<li>Blockchain Application&rsquo;s developers and the users of such applications don&rsquo;t have to trust Oraclize; the security model is mantained.</li>
<li>Data providers don&rsquo;t have to modify their services in order to be compatible with blockchain protocols. Smart contracts can directly access data from Web sites or APIs. </li>
</ul>

<p>Oraclize engine can be easily integrated with both private and public instances of different blockchain protocols.</p>

<p>While building the service, the Oraclize team has realized that the concept of authenticity proofs has much broader applicability that initially envisioned. For example, the Oraclize Random Data-source can be used even by traditional gambling applications to ensure users of continuous fairness of operation</p>

          <h1 id="general-concepts">General Concepts</h1>

<p>Oraclize is integrated with a number of blockchain protocols and its service is usefull and accessible also for non-blockchain applications. In the following section, general concepts which apply to all integrations will be explained.</p>

<h2 id="oraclize-engine">Oraclize Engine</h2>

<p>The Oraclize Engine powers the service for both blockchain-based and non-blockchain-based application. Internally replicates an &ldquo;If This Then That&rdquo; logical model. This means that it will execute a given set of instructions if some other given conditions are met. For example, it could repeatedly verify a condition and only return data or perform an action when the condition has been met. This flexiblity enables the engine to be leveraged in many different ways and contexts, even outside of the blockchain context.</p>

<p>A valid request for data to Oraclize, done via the native blockchain integration or via the HTTP API, should specify the following arguments:
* A Data Source Type
* A Query
* Optionally, an Authenticity Proof Type </p>

<h2 id="data-source-type">Data Source Type</h2>

<p>A data source is a trusted provider of data. It can be a website or web API such as Reuters, Weather.com, BBC.com etc, or a secure application running on an hardware-enforced Trusted Execution Environment (TEE) or an auditable, locked-down virtual machine instance running in a cloud provider. Oraclize currently offers the following types of native data sources:</p>

<ul>
<li><strong>URL</strong>: enables the access to any webpage or HTTP API endpoint</li>
<li><strong>WolframAlpha</strong>: enables native access to WolframAlpha computational engine</li>
<li><strong>IPFS</strong>: provides access to any content stored on an IPFS file</li>
<li><strong>random</strong>: provides untampered random bytes coming from a secure application running on a Ledger Nano S.</li>
<li><strong>computation</strong>: provides the result of arbitrary computation</li>
</ul>

<p>Additionaly, there also some meta data source such as:</p>

<ul>
<li><strong>nested</strong>: enables the combination of different types of data source o multiple requests using the same data source, and it returns an unique result</li>
<li><strong>identity</strong>: it returns the query </li>
<li><strong>decrypt</strong>: it decrypts a string encrypted to the Oraclize private key</li>
</ul>

<h2 id="query">Query</h2>

<p>A query is an array of parameters which needs to evaluated in order to complete a specific data source type request: <code class="prettyprint">query: [ parameter_1, parameters_2, ...];</code></p>

<p>The first parameter is the main argument and it is usually mandatory. For example, in the case of the URL Data Source Type, the first argument is the expected URL where the resource resides. If only the first argument is present, then the URL Data Source assumes that an HTTP GET was requested. The second parameters, which it is optional, should contain the data payload of the HTTP POST request.</p>

<p>The intermediate result of a query may need to be parsed: for example, to extract a precise field in JSON API response. Therefore, the query can also specify parsing helpers to be applied.  </p>

<h2 id="parsing-helpers">Parsing Helpers</h2>

<p>Oraclize offers XML, JSON, XHTML and a binary parser helpers. Examples:</p>

<ul>
<li><strong>JSON Parsing</strong>: To extract the last-price field from the Kraken API, the fist parameter of the query <code class="prettyprint">json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0</code></li>
<li><strong>XML Parser</strong>: </li>
<li><strong>HTML Parser</strong>: helper is useful for HTML scraping. The desired <a href="https://en.wikipedia.org/wiki/XPath" target="_blank">XPATH</a> can be specified as argument of <code class="prettyprint">xpath(..)</code>as shown in the example: <code class="prettyprint">html(https://twitter.com/oraclizeit/status/671316655893561344).xpath(//*[contains(@class, &#39;tweet-text&#39;)]/text())</code>.</li>
<li><strong>Binary Helper</strong>: It can be useful to extract parts of a binary intermediate result by using the <code class="prettyprint">slice(offset,length)</code> operator.
The first parameter is the expected to be the offset, while the second one is the length of the returned slice. 
For example, <code class="prettyprint">binary(https://www.sk.ee/crls/esteid/esteid2015.crl).slice(0,300)</code>returns the raw bytes of the first certificate of the linked certificate revocation list.<br>
<strong>Binary helper must be used with the slice option and only raw binary inputs are accepted</strong></li>
</ul>

<aside class="notice">
Note:
Oraclize `json()` and `xpath()` helpers support respectively JSONPATH and XPATH standards. The JSONPATH implementation is fully compatible with <a href="https://github.com/FlowCommunications/JSONPath#expression-syntax" target="_blank">FlowCommunications JSONPath 0.3.4</a>, which can be easily tested via <a href="https://jsonpath.curiousconcept.com/" target="_blank">this external website</a>. The XPATH implementation that we use is fully compatible with the <a href="https://www.w3.org/TR/xpath/" target="_blank">XPATH 1.0 standard</a>.
</aside>

<h2 id="authenticity-proofs">Authenticity Proofs</h2>

<p>Oraclize is designed to act as an untrusted intermediary. Optionally, a request to Oraclize can specify an authenticity proof. Not all proofs are compatible with all data source types. More details on the authenticity proofs can be found in the &ldquo;<a href="#Security Deep Dive">#Security Deep Dive</a>&rdquo; section.</p>

<aside class="notice">
If Oraclize is unable to generate an authenticity proof for technical reasons, it will return in most cases the result without the requested proof. It is up to the developer to decide how to handle this case in their application: Oraclize recommends to discards the result and create a new query.
</aside>

<h2 id="data-privacy">Data Privacy</h2>

<p>Certain contexts, such as smart contracts on public blockchains, might require a level of privacy to protect data from public scrutiny. Developers can make encrypted Oraclize queries by encrypting an entire query or some of its arguments with the Oraclize public key.
More information can be found in the <a href="#Encrypted Queries">Encrypted Queries</a> section.</p>

          <h1 id="data-sources">Data Sources</h1>

<p>Listed here are the data-sources you can choose from when using our oracle service.<br>Please note that datasource selection is <i>not</i> case-sensitive.</p>

<table>
  <tr>
    <th rowspan="3" style="vertical-align: bottom !important;">Datasource</th>
    <th colspan="3">Distributions</th>
    <th colspan="2" rowspan="2" style="vertical-align: bottom !important;">Proof type</th>
  </tr>
  <tr>
    <td rowspan="2">Ethereum Mainnet<br></td>
    <td rowspan="2">Ethereum Morden</td>
    <td rowspan="2">HTTP API</td>
  </tr>
  <tr>
    <td>None</td>
    <td>TLSNotary</td>
    <td>Android</td>
    <td>Ledger</td>
  </tr>
  <tr>
    <td><a href="#datasources-url">URL</a></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#datasources-random">Random</a></td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>✓</td>
  </tr>
  <tr>
    <td><a href="#datasources-wolframalpha">WolframAlpha</a></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#datasources-blockchain">Blockchain</a></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#datasources-ipfs">IPFS</a><sup> 1</sup></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#datasources-decrypt">decrypt</a></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#datasources-nested">nested</a><sup> 1</sup></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓<sup> 3</sup></td>
    <td>✓</td>
    <td>✓</td>
  </tr>
  <tr>
    <td><a href="#datasources-computation">computation</a><sup> 1</sup></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
</table>

<p><sup> 1</sup> Still experimental</p>

<p><sup> 2</sup> Still experimental, will be available on mainnet once it&rsquo;s stable</p>

<p><sup> 3</sup> Depending on the datasources you choose in sub-queries, proofs may be provided for each of them, but not for the aggregation itself</p>

<h2 id="url">URL</h2>

<p>The most generic data-source we provide is the <code class="prettyprint">URL</code> one, which can be used to access any public API or page on the Internet.
As a first step you need to provide the actual URL whose HTTP <code class="prettyprint">GET</code> / <code class="prettyprint">POST</code> output you want Oraclize to fetch; and optionally the query-string parameters. Oraclize will forward you the response, while optionally attaching the <code class="prettyprint">TLSNotary</code> proof.</p>

<h2 id="wolframalpha">WolframAlpha</h2>

<p>The <code class="prettyprint">WolframAlpha</code> data-source lets you specify as an argument a query to submit to the WolframAlpha knowledge engine. Oraclize will send you back the primary response as a string if any.</p>

<aside class="notice">
There may not always be a primary response for your query, please test your query in advance on our Web IDE widget to make sure your syntax makes sense to Wolfram&rsquo;s engine.
</aside>

<aside class="notice">
Note:
With this data-source we will not give you back the `TLSNotary` proof as returning the whole API response is against WolframAlpha Terms of Service.
</aside>

<h2 id="ipfs">IPFS</h2>

<p>The <code class="prettyprint">IPFS</code> data-source can be used to retrieve the content of a file on the IPFS protocol.</p>

<p>This datasource expects you to specify the IPFS multihash in the query i.e. <code class="prettyprint">QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o</code> will return <code class="prettyprint">&quot;hello world\n&quot;</code> (note that in this case we have a terminating new line because the original IPFS file had it).</p>

<p>Please note that if we fail to fetch the IPFS content within <i>20</i> seconds, the request will fail.</p>

<h2 id="decrypt">decrypt</h2>

<p>Even though the <code class="prettyprint">decrypt</code> datasource can be used as any other, it was specifically designed to be used within the <a href="#datasources-nested"><code class="prettyprint">nested</code></a> datasource to enable partial query encryption.</p>

<p>The result is the decrypted query string. <strong>Please note that all the logic, limitations and tools provided by the <code class="prettyprint">Encryption</code> feature apply here as well.</strong></p>

<h2 id="nested">nested</h2>

<p>The <code class="prettyprint">nested</code> datasource is a meta datasource, it does not provide access to additional services. It was designed to provide some simple aggregation logic, enabling a single query to leverage sub-queries based on any available datasource and produce a single stringas a result.</p>

<p>The <code class="prettyprint">query</code> format is built in a way you that you can specify a sub-datasource and a sub-query as follows: <code class="prettyprint">[datasource_name] query_content</code>.</p>

<p>Please mind the square brackets delimiting the datasource name and the whitespace prefixing the actual sub-query. The sub-query content can optionally be delimited by either single or double quotes.</p>

<p>You can optionally specify more than one sub-query, by using as delimitators the <code class="prettyprint">${</code> special opener and the <code class="prettyprint">}</code> special closer.</p>

<p>Example: <code class="prettyprint">[WolframAlpha] temperature in ${[IPFS] QmP2ZkdsJG7LTw7jBbizTTgY1ZBeen64PqMgCAWz2koJBL}</code></p>
<pre class="highlight javascript"><code><span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"nested"</span><span class="p">,</span> <span class="s2">"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\n{\"jsonrpc\":\"2.0\",\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":${[decrypt] BIm/tGMbfbvgqpywDDC201Jxob7/6+sSkRBtfCXN94GO0C7uD4eQ+aF+9xNJOigntWu8QHXU6XovJqRMEGHhnEnoaVqVWSqH1U1UFyE6WySavcbOb/h8hOfXv+jYBRuhkQr+tHXYrt1wx0P0dRdeCxbLp1nDuq8=},\"n\":1,\"min\":1,\"max\":10000${[identity] \"}\"},\"id\":1${[identity] \"}\"}']"</span><span class="p">,</span> <span class="nx">ORACLIZE_GAS_LIMIT</span> <span class="o">+</span> <span class="nx">safeGas</span><span class="p">);</span>
</code></pre>

<h2 id="computation">computation</h2>

<p><img src="http://i.imgur.com/BPneTYH.png" /></p>

<p>The <code class="prettyprint">computation</code> datasource enables the auditable execution of an application or a script by leveraging a sandboxed Amazon Web Service virtual machine. </p>

<p>The application has to print, on standard output, the result of the computation as the last line before it quits. The result can be up to 2500 characters long. The execution context has to be described by a <a href="https://docs.docker.com/engine/reference/builder/" target="_blank">Dockerfile</a>, where building and running it should start the main application straight away. Currently Oraclize only provides one type of auditable instance: a t2.micro instance.  The Dockerfile initialization and application execution should terminate as soon as possible, as the execution time is capped at 5 minutes.</p>

<p>The developer can send to Oraclize the application binary or the script, its dependency and the Dockerfile by creating an archive and uploading it to IPFS.
The query expects as first argument the IPFS multihash of that archive, while the following arguments will be passed to the execution environment as environmental variables, making them accessible by the application. </p>

<p>Example:</p>

<ol>
<li>Dockerfile content:</li>
</ol>

<p><textarea disabled style="padding:5px;width:490px;height:104px;background-color: #333;color:#FFF;border:none;">
FROM ubuntu:14.04
MAINTAINER Oraclize &ldquo;info@oraclize.it&rdquo;
RUN apt-get update &amp;&amp; apt-get install -y python-numpy
CMD python -c &ldquo;import numpy; print int(numpy.linalg.det(numpy.array([[1,2,3],[7,2,3],[7,6,3]])))&rdquo;</textarea></p>

<ol>
<li><p><code class="prettyprint">zip -r</code><a href="http://ipfs.io/ipfs/QmRxtL9K2de7v7QBYCCrwcjZHjYmuKggZ8xaqZ6UUWvd1s" target="_blank"><code class="prettyprint">archive.zip</code></a><code class="prettyprint">.</code></p></li>
<li><p><code class="prettyprint">ipfs add archive.zip</code></p>

<ul>
<li>Output: <code class="prettyprint">added QmRxtL9K2de7v7QBYCCrwcjZHjYmuKggZ8xaqZ6UUWvd1s archive.zip</code></li>
</ul></li>
<li><p>The query argument is <code class="prettyprint">QmRxtL9K2de7v7QBYCCrwcjZHjYmuKggZ8xaqZ6UUWvd1s</code> and the query result will be <code class="prettyprint">72</code></p></li>
</ol>

<aside class="notice">
Note: if you choose to specify a MAINTAINER in the Dockerfile, we might use the email address specified there to contact you in case any issue arises.
</aside>

<h2 id="random">random</h2>

<p>The design described there prevents Oraclize from tampering with the random results coming from the Trusted Execution Envirnment (TEE) and protects the user from a number of attack vectors.</p>

<p>The authenticity proof, attached with the result, can be easily verified not just off-chain but even by any Solidity contract receiving them. <a href="https://github.com/oraclize/ethereum-examples/tree/master/solidity/random-datasource" target="_blank">The example presented here</a>, showing how to integrate the verification process, discards any random result whose authenticity proofs don&rsquo;t pass the verification process.</p>

<p>The random datasource is leveraging the Ledger proof to prove that the origin of the generated randomness is really a secure Ledger device.</p>

<p>The rationale behind this method of securely feeding off-chain randomness into the blockchain is explained in the <a target="_blank" href="http://www.oraclize.it/papers/random_datasource-rev1.pdf">“A Scalable Architecture for On-Demand, Untrusted Delivery of Entropy”</a> whitepaper.</p>

          <h1 id="integrations">Integrations</h1>

<h2 id="public-chains">Public chains</h2>

<p>Oraclize is integrated natively with the most widely used public blockchain instances like the Ethereum, Bitcoin, Rootstock mainnets and testnets.</p>

<h2 id="private-chains">Private chains</h2>

<p>By using the Oraclize stargate tool it is possible to connect any private blockchain instance to the Oraclize engine.</p>

<h2 id="non-blockchain">Non-blockchain</h2>

<p>Thanks to the features provided by the oraclize-lib, it is possible to fully leverage the Oraclize service potential in any non blockchain context as well.</p>

          <h1 id="diams-nbsp-ethereum">&diams; &nbsp; Ethereum</h1>

<p>The following section is dedicated to the Ethereum and Oraclize integration. 
To better profit from this section of the documentation, previous knowledge of Solidity and Ethereum is required.</p>

<p>The interaction between Oraclize and an Ethereum smart contract is asyncronous. Any request for data is composed of two steps:</p>

<ul>
<li>Firstly, in the most common case, a transaction executing a function of a smart contract is broadcasted by an user. The function contains a special instruction which manifest to Oraclize, who is constantly monitoring the Ethereum blockchain for such instruction, a request for data.</li>
<li>Secondly, according to the parameters of such request, Oraclize will fetch or compute a result, build, sign and broadcast the transaction carrying the result. In the default configuration, such transaction will execute the <code class="prettyprint">__callback</code> function which should be placed in the smart contract by its developer: for this reason, this transaction is refered in the documentation as the Oraclize callback transaction.</li>
</ul>

<p>As said in previous sections, one of the fundamental characteristics of Oraclize is the capability of returning data to a smart contract together with one or more proofs of authenticity of the data. The generation of an authenticity proof is optional and it is a contract-wide setting which must be configured by the smart contract developer before the request for data is initiated. Oraclize always recommends the use of authenticity proofs for production deployments.  </p>

<h2 id="quick-start">Quick Start</h2>
<pre class="highlight javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/oraclize/ethereum-api/oraclizeAPI.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingOraclize</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">EURGBP</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">oraclize_cbAddress</span><span class="p">())</span> <span class="k">throw</span><span class="p">;</span>
        <span class="nx">EURGBP</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">update</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">oraclize_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was sent, standing by for the answer.."</span><span class="p">);</span>
            <span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(http://api.fixer.io/latest?symbols=USD,GBP).rates.GBP"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>The most simple way to introduce the Ethereum - Oraclize integration, it is by showing a working example, such as the smart contract on the right. 
This contract uses Oraclize to fetch the last EUR/GBP from fixer.io APIs. The update process is initiated every time the function updatePrice() is called. The example shows two important components of using Oraclize:</p>

<ul>
<li>The contract should be a child of the contract usingOraclize</li>
<li>The contract usingOraclize is defined in the oraclizeAPI file, which can be fetched from the dedicated Oraclize Github repository. </li>
</ul>

<p>The code in the example is working out of the box if Remix is used to compile and deploy it on any of the Ethereum networks: main-net and the Ropsten, Kovan and Rinkeby testnets. If, instead, another tool is used, it will be necessary to replace the import statement with a local import of the oraclizeAPI.sol file since direct import from Github may not be supported.</p>

<p>To ease development, Oraclize doesn&rsquo;t charge a contract for its first request of data done using the default gas parameters. Successive requests will require the contract to pay the Oraclize fee and the ether necessary to pay for the callback transaction. Both are automatically taken from the contract balance. If the contract doesn&rsquo;t have enough funds in his balance, the request will fail and Oraclize won&rsquo;t return any data. </p>

<h3 id="simple-query">Simple Query</h3>
<pre class="highlight javascript"><code><span class="c1">// This code example will ask Oraclize to send as soon as possible</span>
<span class="c1">// a transaction with the primary result (as a string) of the given</span>
<span class="c1">// formula ("random number between 0 and 100") fetched from the</span>
<span class="c1">// data-source "WolframAlpha".</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"WolframAlpha"</span><span class="p">,</span> <span class="s2">"random number between 0 and 100"</span><span class="p">);</span>

<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"https://api.kraken.com/0/public/Ticker?pair=ETHXBT"</span><span class="p">)</span>

<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span>
  <span class="s2">"json(https://www.therocktrading.com/api/ticker/BTCEUR).result.0.last"</span><span class="p">)</span>

<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"IPFS"</span><span class="p">,</span> <span class="s2">"QmdEJwJG1T9rzHvBD8i69HHuJaRgXRKEQCP7Bh1BVttZbU"</span><span class="p">)</span>

<span class="c1">// The URL datasource also supports a supplement argument, useful for creating HTTP POST requests.</span>
<span class="c1">// If that argument is a valid JSON string, it will be automatically sent as JSON. </span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://shapeshift.io/sendamount).success.deposit"</span><span class="p">,</span>
  <span class="s1">'{"pair":"eth_btc","amount":"1","withdrawal":"1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}'</span><span class="p">)</span>
</code></pre>

<p>A request for data is called <strong>query</strong>. The <code class="prettyprint">oraclize_query</code> is a function, inhered from the parent usingOraclize contract, which expects at least two arguments:</p>

<ul>
<li>A data-source such as <code class="prettyprint">URL</code>, <code class="prettyprint">WolframAlpha</code>, <code class="prettyprint">IPFS</code>, &lsquo;Swarm&rsquo; and others listed here</li>
<li>The argument for the given data-source. For examples:

<ul>
<li>the full <code class="prettyprint">URL</code>, which may inclued the use of JSON or XML parsing helpers as it can be seen in the previous example</li>
<li>or a <code class="prettyprint">WolframAlpha</code> formula</li>
<li>or an <code class="prettyprint">IPFS</code> multihash</li>
</ul></li>
</ul>

<p>The number and type of supported arguments depends from the data-source in use. Beside, few more code example will be shown and commented. The datasource, as well as the authenticity proof chosen, determine the fee which the contract has to pay to Oraclize.  </p>

<h3 id="schedule-a-query-in-the-future">Schedule a Query in the Future</h3>
<pre class="highlight javascript"><code><span class="c1">// Relative time: get the result from the given URL 60 seconds from now</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span>
  <span class="s2">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">)</span>

<span class="c1">// Absolute time: get the result from the given datasource at the specified UTC timestamp in the future</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="nx">scheduled_arrivaltime</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">3600</span><span class="p">,</span>
  <span class="s2">"WolframAlpha"</span><span class="p">,</span> <span class="nx">strConcat</span><span class="p">(</span><span class="s2">"flight "</span><span class="p">,</span> <span class="nx">flight_number</span><span class="p">,</span> <span class="s2">" landed"</span><span class="p">));</span>
</code></pre>

<p>The execution of a query can be scheduled in a future date. The function <code class="prettyprint">oraclize_query</code> accepts as a parameter the delay in seconds from the current time or the timestamp in the future as first argument.
Please note that in order for the future timestamp to be accepted by Oraclize it must be within <strong>60 days</strong> of the current UTC time in the case of the absolute timestamp choice, or in the case of a relative time elapse, the elapsed seconds must equate to no more than <strong>60 days</strong>. </p>

<h3 id="recursive-queries">Recursive Queries</h3>
<pre class="highlight javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/oraclize/ethereum-api/oraclizeAPI.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingOraclize</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">EURGBP</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">oraclize_cbAddress</span><span class="p">())</span> <span class="k">throw</span><span class="p">;</span>
        <span class="nx">EURGBP</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">oraclize_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was sent, standing by for the answer.."</span><span class="p">);</span>
            <span class="nx">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(http://api.fixer.io/latest?symbols=USD,GBP).rates.GBP"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

</code></pre>

<p>Smart contract using Oraclize can be effectively autonomous by implementing a new call to Oraclize into their  <code class="prettyprint">__callback</code> method. 
This can be useful for implementing periodic updates of some on-chain reference data, as with price feeds, or to periodically check for some off-chain conditions.</p>

<p>This modified version of the previous example will update the EUR/GBP exchange rate every 60 seconds, until the contract has enough funds to pay for the Oraclize fee.</p>

<h3 id="the-query-id">The Query ID</h3>
<pre class="highlight javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/oraclize/ethereum-api/oraclizeAPI.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingOraclize</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">EURGBP</span><span class="p">;</span>
    <span class="nx">mapping</span><span class="p">(</span><span class="nx">bytes32</span><span class="o">=&gt;</span><span class="nx">bool</span><span class="p">)</span> <span class="nx">validIds</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span> 

    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">])</span> <span class="k">throw</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">oraclize_cbAddress</span><span class="p">())</span> <span class="k">throw</span><span class="p">;</span>
        <span class="nx">EURGBP</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="k">delete</span> <span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">];</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">oraclize_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was sent, standing by for the answer.."</span><span class="p">);</span>
            <span class="nx">bytes32</span> <span class="nx">queryId</span> <span class="o">=</span> 
                <span class="nx">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(http://api.fixer.io/latest?symbols=USD,GBP).rates.GBP"</span><span class="p">);</span>
            <span class="nx">validIds</span><span class="p">[</span><span class="nx">queryId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Every time the function <code class="prettyprint">oraclize_query</code> is called, it returns a unique ID, hereby refered to as <code class="prettyprint">queryId</code>, which depends from the number of previous requests and the address of smart contract.
The queryId identifies a specific query done to Oraclize and it is returned to the contract as a parameter of the callback transaction. </p>

<p>Oraclize recommends smart contract developers to verify if the queryId sends by the callback transaction was generated by a valid call to the <code class="prettyprint">oracize_query</code> function, as shown in the example accompanying this paragraph. This ensures that each query response is processed only once and helps avoid misuse of the smart contract logic. Moreover, it protects the smart contract during blockchain reorganizations, as explained in the dedicated paragraph of this section.</p>

<p>The <code class="prettyprint">queryId</code> can be used as well to implement different behaviours into the <code class="prettyprint">__callback</code> function, in particular when there is more than one pending call from Oraclize. </p>

<h3 id="custom-gas-limit-and-gas-price">Custom Gas Limit and Gas Price</h3>
<pre class="highlight javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/oraclize/ethereum-api/oraclizeAPI.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingOraclize</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">EURGBP</span><span class="p">;</span>
    <span class="nx">mapping</span><span class="p">(</span><span class="nx">bytes32</span><span class="o">=&gt;</span><span class="nx">bool</span><span class="p">)</span> <span class="nx">validIds</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>

    <span class="c1">// This example requires funds to be send along with the contract deployment</span>
    <span class="c1">// transaction </span>
    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">oraclize_setCustomGasPrice</span><span class="p">(</span><span class="mi">4000000000</span> <span class="nx">wei</span><span class="p">);</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">])</span> <span class="k">throw</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">oraclize_cbAddress</span><span class="p">())</span> <span class="k">throw</span><span class="p">;</span>
        <span class="nx">EURGBP</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="k">delete</span> <span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">];</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">oraclize_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was sent, standing by for the answer.."</span><span class="p">);</span>
            <span class="nx">bytes32</span> <span class="nx">queryId</span> <span class="o">=</span> 
                <span class="nx">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(http://api.fixer.io/latest?symbols=USD,GBP).rates.GBP"</span><span class="p">,</span> <span class="mi">500000</span><span class="p">);</span>
            <span class="nx">validIds</span><span class="p">[</span><span class="nx">queryId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>The transaction originating from Oraclize to the  <code class="prettyprint">__callback</code> function pays a fee to the miner which include the transaction in a block, just like any other transaction. The miner fee is paid in Ether and it is calculated by taking the amount of gas which covers the execution costs of the transaction multiplied by the selected gas/ether price. Oraclize will set those parameters accordingly to the parameters specified in the smart contract, for contract-wide settings, and in the <code class="prettyprint">oraclize_query</code> function, for query-specific settings. The miner fee for the callback transaction is taken from the contract balance when the query transaction is executed.</p>

<p>If no settings are specified, Oraclize will use the default values of 200,000 gas and 20 GWei. This last value is on the higher-end of the pricing spectrum right now, but it helps having faster confirmation times during network-wide congestions. </p>

<p>A different value for the Oraclize callback gas can be passed as the argument <code class="prettyprint">_gasLimit</code> to the <code class="prettyprint">oraclize_query</code> function as shown in the following examples.</p>
<pre class="highlight javascript"><code><span class="c1">// If the callback transaction requires little gas, the value can be lowered:</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(http://api.fixer.io/latest?symbols=USD,GBP).rates.GBP"</span><span class="p">,</span> <span class="mi">100000</span><span class="p">);</span>

<span class="c1">// Callback methods may be expensive. The example requires the JSON parsing </span>
<span class="c1">// a string in the smart contract. If that's the case, the gas should be increased:</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"https://api.fixer.io/latest?symbols=USD,GBP"</span><span class="p">,</span> <span class="mi">500000</span><span class="p">);</span>
</code></pre>

<p>The gas price of the callback transaction can be set by calling the <code class="prettyprint">oraclize_setCustomGasPrice</code> function, either in the constructor, which is executed once at deployment of the smart contract, or in a separate function. The following is the ExampleContract modified to specify a custom gas price of 4 Gwei and a custom gas limit for the callback transaction.</p>

<p>Smart contract developers should estimate correctly and minimize the cost of their <code class="prettyprint">__callback</code> method, as any unspent gas will be returned to Oraclize and no refund is available. </p>

<h3 id="authenticity-proofs">Authenticity Proofs</h3>
<pre class="highlight javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/oraclize/ethereum-api/oraclizeAPI.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingOraclize</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">EURGBP</span><span class="p">;</span>
    <span class="nx">mapping</span><span class="p">(</span><span class="nx">bytes32</span><span class="o">=&gt;</span><span class="nx">bool</span><span class="p">)</span> <span class="nx">validIds</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">updatePrice</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>


    <span class="c1">// This example requires funds to be send along with the contract deployment</span>
    <span class="c1">// transaction </span>
    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">oraclize_setCustomGasPrice</span><span class="p">(</span><span class="mi">4000000000</span> <span class="nx">wei</span><span class="p">);</span>
        <span class="nx">oraclize_setProof</span><span class="p">(</span><span class="nx">proofType_TLSNotary</span> <span class="o">|</span> <span class="nx">proofStorage_IPFS</span><span class="p">);</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">bytes</span> <span class="nx">proof</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">])</span> <span class="k">throw</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">oraclize_cbAddress</span><span class="p">())</span> <span class="k">throw</span><span class="p">;</span>
        <span class="nx">EURGBP</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">updatedPrice</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="k">delete</span> <span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">];</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">oraclize_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">newOraclizeQuery</span><span class="p">(</span><span class="s2">"Oraclize query was sent, standing by for the answer.."</span><span class="p">);</span>
            <span class="nx">bytes32</span> <span class="nx">queryId</span> <span class="o">=</span> 
                <span class="nx">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.fixer.io/latest?symbols=USD,GBP).rates.GBP"</span><span class="p">,</span> <span class="mi">500000</span><span class="p">);</span>
            <span class="nx">validIds</span><span class="p">[</span><span class="nx">queryId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Authenticity proofs are at the core of Oraclize&rsquo;s oracle model. Smart contracts can request authenticity proofs together with their data by calling the <code class="prettyprint">oraclize_setProof</code> function available in the usingOraclize. The authenticity proof can be either deliver directly to the smart contract or it can be saved, upload and stored on <a href="http://ipfs.io/" target="_blank">IPFS</a>. </p>

<p>When a smart contract requests for an authenticity proof, it <strong>must</strong> define a different callback function with the following arguments: <code class="prettyprint">function __callback(bytes32 queryId, string result, bytes proof)</code></p>

<p>The <code class="prettyprint">oraclize_setProof</code> function expects the following format: <code class="prettyprint">oraclize_setProof(proofType_ | proofStorage_ )</code></p>

<p>Both proofType and proofStorage are byte constants defined in usingOraclize:  </p>

<p>Available parameters for proofTypes are:</p>

<ul>
<li><code class="prettyprint">proofType_NONE</code>: the default value of any smart contracts </li>
<li><code class="prettyprint">proofType_TLSNotary</code> </li>
<li><code class="prettyprint">proofType_Android</code></li>
<li><code class="prettyprint">proofType_Native</code></li>
<li><code class="prettyprint">proofType_Ledger</code> </li>
</ul>

<p>While for proofStorage:</p>

<ul>
<li><code class="prettyprint">proofStorage_IPFS</code></li>
</ul>

<p>For example, <code class="prettyprint">oraclize_setProof(proofType_TLSNotary)</code> will return the full TLSNotary Proof bytes as the proof argument in the callback transaction. If instead <code class="prettyprint">oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS)</code> is used, then Oraclize will return only the base58-decoded IPFS multihash as the proof argument. To obtain the IPFS multihash, the bytes must be encoded to base58. 
The method <code class="prettyprint">oraclize_setProof</code> can be executed in the constructor, becoming a contract-wide lasting setting, or it can be set directly before a specific query is to be made. Authentiticity proofs can be disabled by calling <code class="prettyprint">oraclize_setProof(proofType_NONE)</code>. Smart contract developer should be aware that the helper method <code class="prettyprint">oraclize_setProof</code> is an internal function of usingOraclize, and therefore it must be included specifically in their smart contract at compile time, before deployment. 
The following builds on our previous example:</p>

<h3 id="verifiability">Verifiability</h3>

<p>Supported proofs can be verified. The following tools can be used: <a href="#development-tools-network-monitor">Verification Tools</a> </p>

<h2 id="advanced-topics">Advanced Topics</h2>

<h3 id="encrypted-queries">Encrypted Queries</h3>

<p>Certain contexts, such as smart contracts on public blockchains, might require a level of privacy to protect data from public scrutiny. Developers can make encrypted Oraclize queries by encrypting a part (or all) of a query with the Oraclize public key.
The encrypted queries feature may be of interested to developers who want to deploy their blockchain applications of public networks. For example, if an application leverages data from an authenticated API, it would be dangerous to disclose the API key to anyway who is monitoring the public chain.  </p>

<p>Oraclize therefore offers the possibility of encrypting the parameters contained in a query to Oraclize&rsquo;s public key: `044992e9473b7d90ca54d2886c7addd14a61109af202f1c95e218b0c99eb060c7134c4ae46345d0383ac996185762f04997d6fd6c393c86e4325c469741e64eca9.
Only Oraclize will then be able to decrypt the request using its paired private key. </p>

<p>To encrypt the query, Oraclize provides a CLI tool, which can be found <a href="https://github.com/oraclize/encrypted-queries" target="_blank">here</a>. Alternatively,<br>
The CLI command to encrypt an arbitrary string of text is then:</p>

<p><code class="prettyprint">python encrypted_queries_tools.py -e -p 044992e9473b7d90ca54d2886c7addd14a61109af202f1c95e218b0c99eb060c7134c4ae46345d0383ac996185762f04997d6fd6c393c86e4325c469741e64eca9 &quot;YOUR QUERY&quot;</code></p>

<p>This will encrypt the query with the default Oraclize public key. The encrypted string can then be used as an argument for an Oraclize query.</p>
<pre class="highlight javascript"><code><span class="c1">// In this example, the entire first argument of an oraclize_query has been encrypted.</span>
<span class="c1">// The actual string encrypted is:  json(https://poloniex.com/public?command=returnTicker).BTC_ETH.last</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span><span class="s2">"AzK149Vj4z65WphbBPiuWQ2PStTINeVp5sS9PSwqZi8NsjQy6jJLH765qQu3U/
  bZPNeEB/bYZJYBivwmmREXTGjmKJk/62ikcO6mIMQfB5jBVVUOqzzZ/A8ecWR2nOLv0CKkkkFzBYp2sW1H
  31GI+SQzWV9q64WdqZsAa4gXqHb6jmLkVFjOGI0JvrA/Zh6T5lyeLPSmaslI"</span><span class="p">);</span>
</code></pre>

<aside class="notice">
You could also encrypt only 1 parameter of oraclize_query(), leaving the other ones in cleartext.
</aside>

<p>The encryption method is also available for POST requests: you can encrypt both the URL and the POST data field as in the following example:</p>
<pre class="highlight javascript"><code><span class="c1">// This is the query that we want to encrypt</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span><span class="s2">"json(https://api.postcodes.io/postcodes).status"</span><span class="p">,</span>
  <span class="s1">'{"postcodes" : ["OX49 5NU", "M32 0JG", "NE30 1DP"]}'</span><span class="p">)</span>
</code></pre>

<p>Encrypt the datasource (URL in this case):<br>
<code class="prettyprint">python encrypted_queries_tools.py -e -p 044992e94... &quot;URL&quot;</code></p>

<p>Returns: <br>
<code class="prettyprint">BEIGVzv6fJcFiYQNZF8ArHnvNMAsAWBz8Zwl0YCsy4K/RJTN8ERHfBWtSfYHt+uegdD1wtXTkP30sTW+3xR3w/un1i3caSO0Rfa+wmIMmNHt4aOS</code>
<br>
<br></p>

<p>Encrypt the argument(in this case we are using the JSON parsing helper to retrieve the &ldquo;status&rdquo; ):<br>
<code class="prettyprint">python encrypted_queries_tools.py -e -p 044992e94... &quot;json(https://api.postcodes.io/postcodes).status&quot;</code></p>

<p>Returns:<br>
<code class="prettyprint">BNKdFtmfmazLLR/bfey4mP8v/R5zCIUK7obcUrF2d6CWUMvKKUorQqYZNu1YfRZsGlp/F96CAQhSGomJC7oJa3PktwoW5J1Oti/y2v4+b5+vN8yLIj1trS7p1l341Jf66AjaxnoFPplwLqE=</code>
<br>
<br></p>

<p>Encrypt the JSON (third argument, the data to POST):<br>
<code class="prettyprint">python encrypted_queries_tools.py -e -p 044992e94... &#39;{&quot;postcodes&quot; : [&quot;OX49 5NU&quot;, &quot;M32 0JG&quot;, &quot;NE30 1DP&quot;]}&#39;</code></p>

<p>Returns:<br>
<code class="prettyprint">BF5u1td9ugoacDabyfVzoTxPBxGNtmXuGV7AFcO1GLmXkXIKlBcAcelvaTKIbmaA6lXwZCJCSeWDHJOirHiEl1LtR8lCt+1ISttWuvpJ6sPx3Y/QxTajYzxZfQb6nCGkv+8cczX0PrqKKwOn/Elf9kpQQCXeMglunT09H2B4HfRs7uuI</code>
<br>
<br></p>
<pre class="highlight javascript"><code><span class="c1">// Finally we add all the encrypted text </span>
<span class="c1">// to the oraclize_query (in the right order)</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"BEIGVzv6fJcFiYQNZF8ArHnvNMAsAWBz8Zwl0YCsy4K/RJTN8ERHfBWtSfYHt+
  uegdD1wtXTkP30sTW+3xR3w/un1i3caSO0Rfa+wmIMmNHt4aOS"</span><span class="p">,</span><span class="s2">"BNKdFtmfmazLLR/bfey4mP8
  v/R5zCIUK7obcUrF2d6CWUMvKKUorQqYZNu1YfRZsGlp/F96CAQhSGomJC7oJa3PktwoW5J1Oti/
  y2v4+b5+vN8yLIj1trS7p1l341Jf66AjaxnoFPplwLqE="</span><span class="p">,</span> <span class="s2">"BF5u1td9ugoacDabyfVzoTxPBxG
  NtmXuGV7AFcO1GLmXkXIKlBcAcelvaTKIbmaA6lXwZCJCSeWDHJOirHiEl1LtR8lCt+1ISttWuvp
  J6sPx3Y/QxTajYzxZfQb6nCGkv+8cczX0PrqKKwOn/Elf9kpQQCXeMglunT09H2B4HfRs7uuI"</span><span class="p">);</span>
</code></pre>

<p>You can also do this with a request to another datasource like WolframAlpha, the Bitcoin blockchain, or IPFS. Our encryption system also permits users to encrypt any of the supported datasource options.</p>

<aside class="notice">
In order to prevent other users from using your exact encrypted query (&ldquo;replay attacks&rdquo;), the first contract querying Oraclize with a given encrypted query becomes its rightful &ldquo;owner&rdquo;. Any other contract using that exact same string will receive an empty result. 

As a consequence, remember to always generate a new encrypted string when re-deploying contracts using encrypted queries.
</aside>

<p>To protect the plaintext queries, an Elliptic Curve Integrated Encryption Scheme was chosen. The steps performed for the encryption are the following ones:</p>

<ul>
<li>An Elliptic Curve Diffie-Hellman Key Exchange (ECDH), which uses secp256k1 as curve and ANSI X9.63 with SHA256 as Key Derivation Function. This algorithm is used to derive a shared secret from the Oraclize public key and ad-hoc, randomly generated developer private key.</li>
<li>The shared secret is used by an AES-256 in Galois Counter Mode (GCM), an authenticated symmetric cipher, to encrypt the query string. The authentication tag is 16-bytes of length and the IV is chosen to be &#39;000000000000&rsquo; (96 bits of length). The IV can be set to the zero byte-array because each shared secret is thrown-away and use only once. Every time the encryption function is called a new developer private key is re-generated. The final ciphertext is the concatenation of the encoded point (i.e the public key of the developer), the authentication tag and the encrypted text.</li>
</ul>

<h3 id="more-examples">More Examples</h3>

<p>More complete, complex examples are available on the dedicated Github repository: <a href="https://github.com/oraclize/ethereum-examples" target="_blank">https://github.com/oraclize/ethereum-examples</a></p>

          <h1 id="9784-nbsp-rootstock">&#9784; &nbsp; Rootstock</h1>

<p>The Oraclize integration with Roostock is fully compatible with the one we have with Ethereum, please refer to that one.</p>

          <h1 id="9737-nbsp-monax">&#9737; &nbsp; Monax</h1>

<p>The Oraclize integration with Monax, previously Eris, is fully compatible with the one we have with Ethereum, please refer to that one.</p>

          <h1 id="3647-nbsp-bitcoin">&#3647; &nbsp; Bitcoin</h1>

<p>The Oraclize integration with Bitcoin works in a very different way compared to the Ethereum one - we plan to document it in the coming weeks, stay tuned!</p>

          <h1 id="development-tools">Development Tools</h1>

<h2 id="test-query">Test query</h2>

<p>The <a href="https://app.oraclize.it/home/test_query" target="_blank">TestQuery</a> page can be used to test any Oraclize query. This does not require any code to be written and can be useful to verify the correctness of a given query during the early development stage.</p>

<h2 id="network-monitor">Network Monitor</h2>

<p>The <a href="https://app.oraclize.it/service/monitor" target="_blank">Network Monitor</a>, along with the <a href="https://github.com/oraclize/proof-verification-tool" target="_blank">Proof Verification Tool</a>, can be used to verify the integrity and correctness of the authenticity proofs Oraclize has provided.</p>

<p>It is very important to independently verify that those proofs are valid, as this is the only way you can verify if Oraclize has ever provided a wrong answer.</p>

<h2 id="encryption">Encryption</h2>

<p>In order to use the encryption-enabling features of Oraclize, you can use tools like the <a href="https://app.oraclize.it/home/test_query" target="_blank">TestQuery</a> page or the <a href="https://github.com/oraclize/encrypted-queries" target="_blank">Python Encryption Tool</a>. Keep in mind that every time you need to use the same encrypted content in a different Oraclize context (like a different Ethereum contract or a different Oraclize contract), you will need to generate and use a different encrypted string; this is to prevent replay attacks.</p>

<h2 id="stargate">Stargate</h2>

<p>If you need to use Oraclize in a private testnet, the Stargate tool enables a full integration of the service in your private context. You can find more information on how to use it in the dedicated section of the documentation. </p>

<h2 id="browser-solidity">Browser-solidity</h2>

<p>The <a href="http://dapps.oraclize.it/browser-solidity/" target="_blank">Oraclize browser-solidity</a> plugin enables you to test Ethereum Oraclize-based contracts straight from your browser (in &ldquo;VM mode&rdquo;), with no need for you to install or setup anything. This is a very handy tool to use fo development.</p>

<h2 id="truffle-amp-ethpm">Truffle &amp; ethpm</h2>

<p>When testing your Oraclize-based contracts with Truffle, you can fully benefit from our ethpm integration and download the oraclizeAPI Solidity contract just by typing <code class="prettyprint">truffle install oraclize</code>.</p>

<h2 id="oraclize-lib">Oraclize-lib</h2>

<p><a href="https://github.com/oraclize/oraclize-lib" target="_blank">Oraclize-lib</a> is a nodejs library that you can use to build applications based on top of the Oraclize service. Note that this isn&rsquo;t dependant on a blockchain in any way and therefore could be integrated into any service!</p>

          <h1 id="security-deep-dive">Security Deep Dive</h1>

<p>As digital technologies have reduced the barrier to entries for information creation and distribution, it has become extremely important to be able to authenticate a piece of information as originating from a known, trusted source. </p>

<p>In the context of web technologies, <em>authentication</em> is provided by the HTTPS protocol, an extension of the HTTP protocol which create an encrypted and authenticated channel between the client and the web-server containing the data.</p>

<p>When dealing with data which could be used to determine different financial transactions, authentication becomes of fundamental importance. Unfortunately, the most used and available blockchain protocols have no direct way of interacting with HTTPS and therefore digesting authenticated data. It would seem then that there is a need for a trusted service which can provide this data or complete actions based on it; but that would in part defeat the point of having a decentralized protocol for exchanging value <em>without</em> trusted parties. </p>

<p>This is the reason why Oraclize has been designing systems for authenticating data and made it part of its core business. These systems are called <em>authenticity proofs</em>, which enable auditability of the oracle&rsquo;s service record in delivering untampered data. 
The authenticity proofs leverage different attestation technologies: some are software-based and some rely on trusted hardware technologies. </p>

<h2 id="authenticity-proofs">Authenticity Proofs</h2>

<h3 id="tlsnotary-proof">TLSNotary Proof</h3>

<p>The TLSNotary Proof leverages a feature of the TLS 1.0 and 1.1 protocols which enables the splitting of the TLS master key between three parties: the server, an auditee and an auditor. In this scheme, Oraclize is the auditee while a locked-down AWS instance of a specially-designed, open-source Amazon Machine Image acts as the auditor. The TLSNotary protocol is an open-source technology, developed and used by the PageSigner project.</p>

<h3 id="android-proof">Android Proof</h3>

<p>The Android Proof is a result of some of Oraclize&rsquo;s internal R&amp;D work. It leverages software remote attestation technology developed by Google, called SafetyNet, to validate that a given Android application is running on a safe, non-rooted physical device, connected to Oraclize&rsquo;s infrastructure. It also remotely validates the application code hash, enabling authentication of the application running on the device. The application code is open-source, thereby enabling auditability and verification of the code hash. The Android Proof goes further, by using the newly introduced Android Hardware Attestion to prove that the physical device is updated to the latest available Android version, further ensuring integrity by having any potential exploits within the system patched. Furthermore, it verifies that the device&rsquo;s Root-of-Binding-Trust is valid. Both these technologies together effectively turn the physical Android device into a provably-secure environment in which an untampered HTTPS connection to a remote datasource can be initiated. For Oraclize or an external attacker with unauthorized gained access to the infrastructure to compromise the device and generate a false but valid proof, a zero-day exploit unbeknownst to Google must be discovered by said party, which either breaks the Android sandboxing model or is a kernel-level exploit, of the latest version of Android OS and its available security patches.
You can access more information about the Android Proof by reading the white paper on it and experiment with it on the Ethereum and Bitcoin testnets. The enabling of the Android Proof on mainnet is pending based on an update by Google, effectively enabling Android Nougat Hardware Attestation.</p>

<h3 id="storage-and-delivery">Storage and Delivery</h3>

<p>The authenticity proofs may be relatively large files, of up to a few kilobytes. Delivering such proofs directly within the result of the data payload in an Ethereum transaction can get quite expensive, in terms of EVM execution costs, and may even be impossible for larger data. </p>

<p>Moreover, Oraclize strives to be blockchain agnostic, enabling the proof to be used even on Bitcoin and other blockchains. Therefore the proof is uploaded and saved to IPFS, a decentralized and distributed storage system. In providing a pointer to the content, IPFS uses a custom hashing algorithm called multihash. The resulting address is Base64 encoded and it&rsquo;s a unique ID specific to the file which can be used to access it globally, and changes along with any edits to the file contained. </p>

<p>IPFS, by itself, doesn&rsquo;t provide any long-term guarantees of persistency, however as part of Oraclize&rsquo;s infrastructures it runs the <a href="https://github.com/oraclize/ipfs-persistence-consortium" target="_blank">IPFS persistence consortium</a>. Anyone can join Oraclize&rsquo;s consortium and help in keeping an independent copy of all the proofs by pointing a <a href="https://github.com/oraclize/ipfs-persistence-consortium" target="_blank">IPFS persistence consortium</a> node to the following aggregation peer: <code class="prettyprint">QmSsSSfJAJwj3jsNfzbSrxtLAjhpYPjbUEsCQT8mWVgBiL</code></p>

          <h1 id="pricing">Pricing</h1>

<p>The use of Oraclize APIs requires the payment of a small fee, you can check out the pricing for each integration below:</p>

<ul>
<li><a href="#pricing-ethereum">Ethereum</a></li>
</ul>

<h2 id="ethereum">Ethereum</h2>

<p>The fee for Ethereum comes on top of the reimbursement for the full <code class="prettyprint">gasLimit</code> we are setting in the transaction when we call back your contract.</p>

<h3 id="free-calls">Free calls</h3>

<p>In order to make the testing of our service a little bit easier (and cheaper) to you, <strong>the first Oraclize query call coming from any Ethereum address is completely free of charge</strong>. This means we are even covering the callback transaction gas costs for you (up to the default <code class="prettyprint">gasLimit</code> of 200k gas).</p>

<p>This might be helpful, for example, to send the first call to Oraclize directly from your contract constructor function without having to create your contract with an attached amount of Wei. This means, again, that you can have one free triggering transaction for any date in the future (up to 60 days).</p>

<aside class="notice">
Note: Oraclize calls are free when used on testnets! This works for moderate usage in test environments only.
</aside>

<h3 id="call-fees">Call fees</h3>

<p>Payment is part and parcel of the <code class="prettyprint">oraclize_query</code> function call, and our pricing model is simple. It&rsquo;s composed of two parts:</p>

<ul>
<li>a price in $ depending on the datasource used and the proof chosen (see table below). This $ price is automatically converted to Ether at the current rate when you call <code class="prettyprint">oraclize_query</code></li>
<li>a prepayment of the full <code class="prettyprint">gasLimit</code> we will set for the callback transaction (the minimum and default value is 200k gas)</li>
</ul>

<style type="text/css">
    tr, td, th {
        text-align: center !important;
        vertical-align: middle !important;
    }
</style>

<table>
  <tr>
    <th rowspan="2" style="vertical-align: bottom !important;">Datasource</th>
    <th rowspan="2" style="vertical-align: bottom !important;">Base price</th>
    <th colspan="4">Proof type</th>
  </tr>
  <tr>
    <td>None</td>
    <td>TLSNotary</td>
    <td>Android</td>
    <td>Ledger</td>
  </tr>
  <tr>
    <td>URL</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.01$</td>
    <td>+0.0$</td>
    <td>+0.04$</td>
    <td>+0.04$</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>Blockchain</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.01$</td>
    <td>+0.0$</td>
    <td>+0.04$</td>
    <td>+0.04$</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>WolframAlpha</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.03$</td>
    <td>+0.0$</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>IPFS</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.01$</td>
    <td>+0.0$</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>random</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.05$</td>
    <td>+0.0$</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>+0.0$</td>
  </tr>
  <tr>
    <td>computation</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.50$</td>
    <td>+0.0$</td>
    <td>+0.04$</td>
    <td>+0.04$</td>
    <td>N/A</td>
  </tr>
</table>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="javascript"></a>
          </div>
      </div>
    </div>
    <span id='chat'><a href='https://gitter.im/oraclize/' target='_blank'><img src='images/gitter.png' width=120></a></span>
    <script>
    var isMobile = false; //initiate as false
    // device detection
    if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) isMobile = true;
    
    if (!isMobile){
      $(document).ready(function(){
        setTimeout(function(){
          $("#chat").slideDown();
        }, 1500);
      });
      $("#chat img").mouseover(function(){ $(this).animate({width: "140px"}, "fast"); });
      $("#chat img").mouseout(function(){ $(this).animate({width: "120px"}, "fast"); });
    }
    
    $.get('lastupdate.txt', function(date){
	$('#lastupdate').html('Last update: '+date.trim());
    }, 'text');

    $('a[href^="#"]').on('click',function(e){
      e.preventDefault();
      var href = $(this).attr('href');
      if(typeof(href)=='undefined') return;
      if(href.indexOf('-')!==-1) scrollToSection(href);
      else location.hash = href;
    });

    function scrollToSection(href){
      $('html,body').animate({
        scrollTop: $('div[data-unique='+href.substr(1)+']').offset().top+60,
      },0);
    }
    </script>
  </body>
</html>
