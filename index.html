<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>

    <style>
      #logoc {
        text-align: center;
        left: 0;
        right: 0;
        margin: auto;
      }
      #logoMAIN {
        padding: 10px;
        text-align: center;
        left: 0;
        right: 0;
        margin: auto;
      }
      #logoText {
        text-align: center;
        left: 0;
        right: 0;
        margin: auto;
        color: #FFF;
        font-size: 1.75em;
      }
      #lastupdate {
	position:absolute;
	bottom:0;
	font-size:1.13em;
	font-style:italic;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;javascript&quot;,&quot;python&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <div id="logoc">
      <img src="images/logo.png" alt="Oraclize log" id="logoMAIN" width="50px"><br> <span id="logoText">Oraclize</span>
      </div>
        <div class="lang-selector">
              <a href="#" data-language-name="javascript">Solidity</a>
              <a href="#" data-language-name="python">Serpent</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><span id='lastupdate'></span></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        
          <h1 id="overview">Overview</h1>

<p>Oraclize is a <u title="(the amount of trust involved is close to zero)">provably-honest oracle</u> service enabling smart contracts to access the Internet.</p>

<p>We are platform-agnostic and provide an abstraction interface to all the major smart-contracts-capable platforms out there (Bitcoin and Ethereum at the time of writing).
We think that it&rsquo;s just by throwing tons of meaningful data into the blockchain jar that the smart contracts industry can flourish and many useful applications can finally come to life.</p>

<p>While any platform is providing access to on-chain data only, Oraclize provides them with an interface to any data-feed on the Internet.</p>

<p>This documentation covers our API integration with the <strong>Ethereum</strong> platform.</p>

<p>The documentation covering our <strong>HTTP API</strong> and the <strong>Bitcoin integration</strong> are coming soon.</p>

<h2 id="problem">Problem</h2>

<p>Even though the oracle concept, in the blockchain sense, has been around for a while, we haven&rsquo;t seen any advanced implementations. All implementations were nothing more than proof of concepts or of very limited use in themselves.</p>

<p>One of the reasons for this failure to provide a proper oracle service is that trying to build a distributed oracle network where nodes attempt to find consensus to a specific query is very hard and needs a proper inter-oracle communication protocol (which Orisi was a first attempt to build) rather than merely a convincing incentive for the oracles not to lie.</p>

<h2 id="how-does-an-oracle-work">How does an oracle work</h2>

<p>An oracle, in the blockchain sense, is a third party which sends to your on-chain smart contract some specific data your smart contract code cannot fetch by itself. As the oracle is a centralized party, you shouldn&rsquo;t take its response for granted.</p>

<p>For example, if you ask an oracle to give you the last trading price of ETH/USD the oracle needs to fetch this data from some exchanges on the Internet and than send this data back to you. While doing this the oracle might compromise the exchange data and send back to you a compromised value. This is the reason why, by itself, the oracle cannot be trusted. It is important to trust the data-feed provider (in our example this is the exchange trading the ETH/USD pair) but this can easily be mitigated by using different data-sources and using them to determine consensus.</p>

<p>However, how can we trust the oracle not to alter this data in the first place? This is achievable using the same mitigation technique we just explained above for data-sources or by using a cryptographic proof such as the TLSNotary one.</p>

<h2 id="our-solution">Our solution</h2>

<p>Oraclize wants to fill in this industry gap by providing an oracle service which is as generic as possible. We are not trying to build the Internet here but to provide a good compromise instead.</p>

<p>Although we are a centralized service we share the vision behind decentralized networks and we understand how reputation is key which is why we are providing a provably-honest service too.</p>

<p><img src="images/flowchart.png" /></p>

          <h1 id="datasources">Datasources</h1>

<p>We list here the data-sources you can choose from when using our oracle service.<br>Please note that datasource selection is <i>not</i> case-sensitive.</p>

<table>
  <tr>
    <th rowspan="3" style="vertical-align: bottom !important;">Datasource</th>
    <th colspan="3">Distributions</th>
    <th colspan="2" rowspan="2" style="vertical-align: bottom !important;">Proof type</th>
  </tr>
  <tr>
    <td rowspan="2">Ethereum Mainnet<br></td>
    <td rowspan="2">Ethereum Morden</td>
    <td rowspan="2">HTTP API</td>
  </tr>
  <tr>
    <td>None</td>
    <td>TLSNotary</td>
  </tr>
  <tr>
    <td><a href="#datasources-url">URL</a></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
  </tr>
  <tr>
    <td><a href="#datasources-wolframalpha">WolframAlpha</a></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#datasources-blockchain">Blockchain</a></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
  </tr>
  <tr>
    <td><a href="#datasources-ipfs">IPFS</a><sup> 1</sup></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#datasources-decrypt">decrypt</a></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#datasources-nested">nested</a><sup> 1</sup></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓<sup> 3</sup></td>
  </tr>
  <tr>
    <td><a href="#datasources-computation">computation</a><sup> 1</sup></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
  </tr>
</table>

<p><sup> 1</sup> Still experimental</p>

<p><sup> 2</sup> Still experimental, will be available on mainnet once it&rsquo;s stable</p>

<p><sup> 3</sup> Depending on the datasources you choose in sub-queries, proofs may be provided for each of them, but not for the aggregation itself</p>

<h2 id="url">URL</h2>

<p>The most generic data-source we provide is the <code class="prettyprint">URL</code> one, which can be used to access any public API or page on the Internet.
As a first step you need to provide the actual URL whose HTTP <code class="prettyprint">GET</code> / <code class="prettyprint">POST</code> output you want Oraclize to fetch; and optionally the query-string parameters. Oraclize will forward you the response, while optionally attaching the <code class="prettyprint">TLSNotary</code> proof.</p>

<h2 id="wolframalpha">WolframAlpha</h2>

<p>The <code class="prettyprint">WolframAlpha</code> data-source lets you specify as argument a query to submit to the WolframAlpha knowledge engine. Oraclize will send you back the primary response as a string if any.</p>

<aside class="notice">
There may not always be a primary response for your query, please test your query in advance on our Web IDE widget to make sure your syntax makes sense to Wolfram&rsquo;s engine.
</aside>

<aside class="notice">
Note:
With this data-source we will not give you back the `TLSNotary` proof as returning the whole API response is against WolframAlpha Terms of Service.
</aside>

<h2 id="blockchain">Blockchain</h2>

<p>The <code class="prettyprint">Blockchain</code> data-source provides you with easy access to blockchain-related data. You can see this data-source as a shortcut to common block explorer APIs, but with a built-in easy-to-use syntax.
Possible query arguments are:</p>

<ul>
<li><code class="prettyprint">bitcoin blockchain height</code>,</li>
<li><code class="prettyprint">litecoin hashrate</code>,</li>
<li><code class="prettyprint">bitcoin difficulty</code>, </li>
<li><code class="prettyprint">1NPFRDJuEdyqEn2nmLNaWMfojNksFjbL4S balance</code> 
and so on.</li>
</ul>

<h2 id="ipfs">IPFS</h2>

<p>The <code class="prettyprint">IPFS</code> data-source can be used to retrieve the content of a file on the IPFS protocol.</p>

<p>This datasource expects you to specify the IPFS multihash in the query i.e. <code class="prettyprint">QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o</code> will return <code class="prettyprint">&quot;hello world\n&quot;</code> (note that in this case we have a terminating new line because the original IPFS file had it).</p>

<p>Please note that if we fail to fetch the IPFS content within <i>20</i> seconds, such request will fail.</p>

<h2 id="decrypt">decrypt</h2>

<p>Even though the <code class="prettyprint">decrypt</code> datasource can be used as any other, it was specifically designed to be used within the <a href="#datasources-nested"><code class="prettyprint">nested</code></a> datasource to enable partial query encryption.</p>

<p>The result is the decrypted query string. <strong>Please note that all the logic, limitations and tools provided by the <code class="prettyprint">Encryption</code> feature do apply here with no modification.</strong></p>

<h2 id="nested">nested</h2>

<p>The <code class="prettyprint">nested</code> datasource is a meta datasource, it does not provide access to additional services. It was designed to provide a simple aggregation logic, enabling a single query to leverage sub-queries based on any available datasource and producing as result a single string.</p>

<p>The <code class="prettyprint">query</code> format is built in a way you can specify a sub-datasource and a sub-query as follows: <code class="prettyprint">[datasource_name] query_content</code>.</p>

<p>Please mind the square brakets delimiting the datasource name and the whitespace prefixing the actual sub-query. The sub-query content can optionally be delimited by either single or double quotes.</p>

<p>You can optionally specify more than one sub-query, by using as delimitators the <code class="prettyprint">${</code> special opener and the <code class="prettyprint">}</code> special closer.</p>

<p>Example: <code class="prettyprint">[WolframAlpha] temperature in ${[IPFS] QmP2ZkdsJG7LTw7jBbizTTgY1ZBeen64PqMgCAWz2koJBL}</code></p>

<h2 id="computation">computation</h2>

<p><img src="http://i.imgur.com/BPneTYH.png" /></p>

<p>The <code class="prettyprint">computation</code> datasource enables the auditable execution of a given application into a secure blockchain-unrelated (off-chain) context.</p>

<p>Such application has to print the query result on the last line (on standard output) before its quits. The execution context has to be described by a <a href="https://docs.docker.com/engine/reference/builder/" target="_blank">Dockerfile</a>, where building and running it should start your main application straight away. The Dockerfile initialization + your application execution should terminate as soon as possible: the <strong>maximum execution timeout is ~5 minutes on an AWS t2.micro instance.</strong></p>

<p>As the query is the IPFS multihash of a zip archive containing such files (Dockerfile + any external file dependencies, the Dockerfile has to be places in the archive root), you should take care of preparing such archive and pushing it to IPFS beforehand.</p>

<p>Example:</p>

<ol>
<li>Dockerfile content:</li>
</ol>

<p><textarea disabled style="padding:5px;width:490px;height:104px;background-color: #333;color:#FFF;border:none;">
FROM ubuntu:14.04
MAINTAINER Oraclize &ldquo;info@oraclize.it&rdquo;
RUN apt-get update &amp;&amp; apt-get install -y python-numpy
CMD python -c &ldquo;import numpy; print int(numpy.linalg.det(numpy.array([[1,2,3],[7,2,3],[7,6,3]])))&rdquo;</textarea></p>

<ol>
<li><p><code class="prettyprint">zip -r</code><a href="http://ipfs.io/ipfs/QmRxtL9K2de7v7QBYCCrwcjZHjYmuKggZ8xaqZ6UUWvd1s" target="_blank"><code class="prettyprint">archive.zip</code></a><code class="prettyprint">.</code></p></li>
<li><p><code class="prettyprint">ipfs add archive.zip</code></p>

<ul>
<li>Output: <code class="prettyprint">added QmRxtL9K2de7v7QBYCCrwcjZHjYmuKggZ8xaqZ6UUWvd1s archive.zip</code></li>
</ul></li>
<li><p>our query argument is <code class="prettyprint">QmRxtL9K2de7v7QBYCCrwcjZHjYmuKggZ8xaqZ6UUWvd1s</code> and the query result will be <code class="prettyprint">72</code></p></li>
</ol>

<aside class="notice">
Note: if you choose to specify a MAINTAINER in the Dockerfile, we might use the email address specified there to contact you in case any issue arises
</aside>

          <h1 id="additional-features">Additional Features</h1>

<h2 id="parsing-helpers">Parsing helpers</h2>

<p>In order to make things simpler to handle on the smart-contract side, you can provide the URL inside one of the following parsing helpers:</p>

<ul>
<li><p><code class="prettyprint">xml(..)</code> and <code class="prettyprint">json(..)</code> helpers let you ask Oraclize to only return part of the JSON or XML-parsed response. 
For example:</p>

<ul>
<li>in order to get the whole response back, you use the <code class="prettyprint">URL</code> data-source with the URL argument <code class="prettyprint">api.kraken.com/0/public/Ticker?pair=ETHUSD</code> </li>
<li>but if all you want is the last-price field, you need to use the <code class="prettyprint">json</code> parsing call as <code class="prettyprint">json(api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0</code></li>
</ul></li>
<li><p><code class="prettyprint">html(..).xpath(..)</code> helper is useful for html scraping. Just specify the <a href="https://en.wikipedia.org/wiki/XPath" target="_blank">XPATH</a> you want as <code class="prettyprint">xpath(..)</code> argument. For Example:</p>

<ul>
<li>to fetch the text of a specific tweet: <code class="prettyprint">html(https://twitter.com/oraclizeit/status/671316655893561344).xpath(//*[contains(@class, &#39;tweet-text&#39;)]/text())</code>.</li>
</ul></li>
</ul>

<aside class="notice">
Note:
Oraclize `json()` and `xpath()` helpers support respectively JSONPATH and XPATH standards. The JSONPATH implementation that we use is fully compatible with <a href="https://github.com/FlowCommunications/JSONPath#expression-syntax" target="_blank">FlowCommunications JSONPath 0.3.4</a>, which can be easily tested via <a href="https://jsonpath.curiousconcept.com/" target="_blank">this external website</a>. The XPATH implementation that we use is fully compatible with the <a href="https://www.w3.org/TR/xpath/" target="_blank">XPATH 1.0 standard</a>.
</aside>

<ul>
<li><code class="prettyprint">binary(..)</code> helper is useful to get binary files such as certificate files

<ul>
<li>to fetch only a portion of the binary file you can use <code class="prettyprint">slice(offset,length)</code> the first parameter is the offset while the second one is the length of the slice you want back (both in <strong>bytes</strong>).<br> example: fetch only the first 300 bytes from a binary CRL: <code class="prettyprint">binary(https://www.sk.ee/crls/esteid/esteid2015.crl).slice(0,300)</code> <strong>binary helper must be used with the slice option and only binary files (not encoded) are accepted</strong></li>
</ul></li>
</ul>

<aside class="notice">
Note:
If and when the server is not responding or unreachable, we will send you an empty response
</aside>

<h2 id="encrypted-queries">Encrypted queries</h2>

<p>There are some use cases where you are interested in not disclosing your clear text query to the blockchain: for example, if your query includes some API secret credentials.</p>

<p>One option is to encrypt the entire query using Oraclize public key <code class="prettyprint">044992e9473b7d90ca54d2886c7addd14a61109af202f1c95e218b0c99eb060c7134c4ae46345d0383ac996185762f04997d6fd6c393c86e4325c469741e64eca9</code></p>

<p>This means your request will be stored in the blockchain in an encrypted form and that only Oraclize will be able to decrypt it by using its paired private key.</p>

<p>To encrypt the query, you can use our <code class="prettyprint">encrypted_queries_tools.py</code> python script (you can find it <a href="https://github.com/oraclize/encrypted-queries" target="_blank">here</a>).</p>

<p>The CLI command to encrypt an arbitrary string of text is then:</p>

<p><code class="prettyprint">python encrypted_queries_tools.py -e -p 044992e9473b7d90ca54d2886c7addd14a61109af202f1c95e218b0c99eb060c7134c4ae46345d0383ac996185762f04997d6fd6c393c86e4325c469741e64eca9 &quot;YOUR QUERY&quot;</code></p>

<p>It will encrypt the query with the default Oraclize public key. You can then use the encrypted string to query Oraclize in an on-chain Ethereum smart contract.</p>
<pre class="highlight javascript"><code><span class="c1">// here we specify the encrypted formula directly</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span><span class="s2">"AzK149Vj4z65WphbBPiuWQ2PStTINeVp5sS9PSwqZi8NsjQy6jJLH765qQu3U/bZPNeEB/bYZJYBivwmmREXTGjmKJk/62ikcO6mIMQfB5jBVVUOqzzZ/A8ecWR2nOLv0CKkkkFzBYp2sW1H31GI+SQzWV9q64WdqZsAa4gXqHb6jmLkVFjOGI0JvrA/Zh6T5lyeLPSmaslI"</span><span class="p">);</span>
</code></pre>
<pre class="highlight python"><code><span class="c"># here we specify the encrypted formula directly</span>
<span class="n">oraclize_query</span><span class="p">(</span><span class="s">"URL"</span><span class="p">,</span><span class="s">"AzK149Vj4z65WphbBPiuWQ2PStTINeVp5sS9PSwqZi8NsjQy6jJLH765qQu3U/bZPNeEB/bYZJYBivwmmREXTGjmKJk/62ikcO6mIMQfB5jBVVUOqzzZ/A8ecWR2nOLv0CKkkkFzBYp2sW1H31GI+SQzWV9q64WdqZsAa4gXqHb6jmLkVFjOGI0JvrA/Zh6T5lyeLPSmaslI"</span><span class="p">);</span>
</code></pre>

<p>In this case, we have encrypted the following string <code class="prettyprint">json(https://poloniex.com/public?command=returnTicker).BTC_ETH.last</code>, which uses the JSON helper to parse the API response, but in the query you can specify any datasource and helper that you want. The example uses a public API, but you can use any private API that only require a secret user key authentication method. </p>

<aside class="notice">
You can also encrypt only 1 parameter of oraclize_query(), leaving the other ones in clear text
</aside>

<p>The encryption method is also available for POST requests: you can encrypt both the URL and the POST data field as in the following example:</p>
<pre class="highlight javascript"><code><span class="c1">// This is the query that we want to encrypt</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span><span class="s2">"json(https://api.postcodes.io/postcodes).status"</span><span class="p">,</span><span class="s1">'{"postcodes" : ["OX49 5NU", "M32 0JG", "NE30 1DP"]}'</span><span class="p">)</span>
</code></pre>
<pre class="highlight python"><code><span class="c"># This is the query that we want to encrypt</span>
<span class="n">oraclize_query</span><span class="p">(</span><span class="s">"URL"</span><span class="p">,</span><span class="s">"json(https://api.postcodes.io/postcodes).status"</span><span class="p">,</span><span class="s">'{"postcodes" : ["OX49 5NU", "M32 0JG", "NE30 1DP"]}'</span><span class="p">)</span>
</code></pre>

<p>Encrypt the datasource (URL in this case):<br>
<code class="prettyprint">python encrypted_queries_tools.py -e -p 044992e94... &quot;URL&quot;</code></p>

<p>Result in: <br>
<code class="prettyprint">BEIGVzv6fJcFiYQNZF8ArHnvNMAsAWBz8Zwl0YCsy4K/RJTN8ERHfBWtSfYHt+uegdD1wtXTkP30sTW+3xR3w/un1i3caSO0Rfa+wmIMmNHt4aOS</code>
<br>
<br></p>

<p>Encrypt the argument(in this case we are using JSON parse helper to retrieve the &ldquo;status&rdquo; ):<br>
<code class="prettyprint">python encrypted_queries_tools.py -e -p 044992e94... &quot;json(https://api.postcodes.io/postcodes).status&quot;</code></p>

<p>Result in:<br>
<code class="prettyprint">BNKdFtmfmazLLR/bfey4mP8v/R5zCIUK7obcUrF2d6CWUMvKKUorQqYZNu1YfRZsGlp/F96CAQhSGomJC7oJa3PktwoW5J1Oti/y2v4+b5+vN8yLIj1trS7p1l341Jf66AjaxnoFPplwLqE=</code>
<br>
<br></p>

<p>Encrypt the JSON (third argument, the data to POST):<br>
<code class="prettyprint">python encrypted_queries_tools.py -e -p 044992e94... &#39;{&quot;postcodes&quot; : [&quot;OX49 5NU&quot;, &quot;M32 0JG&quot;, &quot;NE30 1DP&quot;]}&#39;</code></p>

<p>Result in:<br>
<code class="prettyprint">BF5u1td9ugoacDabyfVzoTxPBxGNtmXuGV7AFcO1GLmXkXIKlBcAcelvaTKIbmaA6lXwZCJCSeWDHJOirHiEl1LtR8lCt+1ISttWuvpJ6sPx3Y/QxTajYzxZfQb6nCGkv+8cczX0PrqKKwOn/Elf9kpQQCXeMglunT09H2B4HfRs7uuI</code>
<br>
<br></p>
<pre class="highlight javascript"><code><span class="c1">// Finally we add all the encrypted text </span>
<span class="c1">// to the oraclize_query (in the right order)</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"BEIGVzv6fJcFiYQNZF8ArHnvNMAsAWBz8Zwl0YCsy4K/RJTN8ERHfBWtSfYHt+uegdD1wtXTkP30sTW+3xR3w/un1i3caSO0Rfa+wmIMmNHt4aOS"</span><span class="p">,</span><span class="s2">"BNKdFtmfmazLLR/bfey4mP8v/R5zCIUK7obcUrF2d6CWUMvKKUorQqYZNu1YfRZsGlp/F96CAQhSGomJC7oJa3PktwoW5J1Oti/y2v4+b5+vN8yLIj1trS7p1l341Jf66AjaxnoFPplwLqE="</span><span class="p">,</span><span class="s2">"BF5u1td9ugoacDabyfVzoTxPBxGNtmXuGV7AFcO1GLmXkXIKlBcAcelvaTKIbmaA6lXwZCJCSeWDHJOirHiEl1LtR8lCt+1ISttWuvpJ6sPx3Y/QxTajYzxZfQb6nCGkv+8cczX0PrqKKwOn/Elf9kpQQCXeMglunT09H2B4HfRs7uuI"</span><span class="p">)</span>
</code></pre>
<pre class="highlight python"><code><span class="c"># Finally we add all the encrypted text</span>
<span class="c"># to the oraclize_query (in the right order)</span>
<span class="n">oraclize_query</span><span class="p">(</span><span class="s">"BEIGVzv6fJcFiYQNZF8ArHnvNMAsAWBz8Zwl0YCsy4K/RJTN8ERHfBWtSfYHt+uegdD1wtXTkP30sTW+3xR3w/un1i3caSO0Rfa+wmIMmNHt4aOS"</span><span class="p">,</span><span class="s">"BNKdFtmfmazLLR/bfey4mP8v/R5zCIUK7obcUrF2d6CWUMvKKUorQqYZNu1YfRZsGlp/F96CAQhSGomJC7oJa3PktwoW5J1Oti/y2v4+b5+vN8yLIj1trS7p1l341Jf66AjaxnoFPplwLqE="</span><span class="p">,</span><span class="s">"BF5u1td9ugoacDabyfVzoTxPBxGNtmXuGV7AFcO1GLmXkXIKlBcAcelvaTKIbmaA6lXwZCJCSeWDHJOirHiEl1LtR8lCt+1ISttWuvpJ6sPx3Y/QxTajYzxZfQb6nCGkv+8cczX0PrqKKwOn/Elf9kpQQCXeMglunT09H2B4HfRs7uuI"</span><span class="p">)</span>
</code></pre>

<p>Another use case may be a request from a datasource, as WolframAlpha, Bitcoin blockchain or IPFS. Our encryption system also permits users to encrypt any of the supported datasource option.</p>

<aside class="notice">
In order to prevent the misuse of encrypted queries (i.e.: replay attacks) the first contract querying Oraclize with a specific encrypted query becomes its rightful owner. Any other contract reusing the exact same string will not be allowed to use it and will receive back an empty result.

As a consequence, remember to always generate a new encrypted string when re-deploying contracts using encrypted queries.
</aside>

<h3 id="chosen-encryption-scheme">Chosen Encryption scheme</h3>

<p>To protect your encrypted queries, we have chosen an Elliptic Curve Integrated Encryption Scheme composed of the following algorithms:</p>

<ul>
<li>An Elliptic Curve Diffie-Hellman Key Exchange (ECDH), which uses secp256k1 as curve and ANSI X9.63 with SHA256 as Key Derivation Function. This algorithm is used to derive a shared secret from the Oraclize public key and the sender private key.</li>
<li>The shared secret is used by an AES-256 in Galois Counter Mode (GCM), an authenticated symmetric cipher, to encrypt the query. The authentication tag is 16-bytes of length and the nonce is chosen to be &lsquo;000000000000&rsquo; (96 bits of length), which is safe because the shared secret is different for every encrypted query. We then return the concatenation of the encoded point (i.e the public key of the senders), the authentication tag and the encrypted text. The rationale for the chosen encryption scheme will be presented soon in a separated document.</li>
</ul>

          <h1 id="security">Security</h1>

<p>Since Oraclize acts as a data carrier, the service could potentially tamper the result and provide some wrong data (different from the one provided by the chosen datasource). In order to avoid this dishonest behaviour, we optionally provide cryptographic proofs showing that this didn&rsquo;t happen.</p>

<p>These <strong>honesty proofs</strong>, as we call them, are generated via different methodologies (based on different forms of SW/HW attestation) which provide you strong authenticity guarantees.</p>

<p>Some of those proofs are based on external projects we leverage, while others were designed by us in-house in order to make our service more and more secure.</p>

<p>We are listing here the honesty proofs that Oraclize provides. Other than the original TLSNotary-based one, we have others in the workings which will be released in the coming weeks.</p>

<h2 id="proofs-storage-amp-delivery">Proofs Storage &amp; delivery</h2>

<h3 id="ipfs"><a href="https://ipfs.io/" target="_blank">IPFS</a></h3>

<p>In some circumstances you might want to avoid including the raw proof data into your response. One reason could be the fact that the delivery method you choose is expensive (i.e.: Ethereum transactions).
IPFS can be used as storage &amp; delivery method, by making the proof data both permanent and persistent.</p>

<p>IPFS enables the permanence of the proof data by design. This means that your query result can include the multihash of the proof data only, while the actual content can be pinned to IPFS nodes and float around the network whenever you try reaching such a multihash-addressed content.</p>

<p>IPFS doesn&rsquo;t provide by itself any persistency guarantee, however we run as part of our infrastructure a <a href="https://github.com/oraclize/ipfs-persistence-consortium" target="_blank">IPFS persistence consortium</a>.</p>

<p>You can help in keeping an independent copy of our proofs data by pointing your <a href="https://github.com/oraclize/ipfs-persistence-consortium" target="_blank">IPFS persistence consortium</a> node to the following aggregation peer: <code class="prettyprint">QmSsSSfJAJwj3jsNfzbSrxtLAjhpYPjbUEsCQT8mWVgBiL</code></p>

<h2 id="tlsnotary-proof">TLSNotary proof</h2>

<p>TLSNotary is a project implementing a modification of TLS. By using it you can prove that a certain server has really sent some data to you at a given point in time.</p>

<p>Pagesigner is a TLSNotary-based system which is designed to generate a distributable proof that anybody can use to indipendently verify the authenticity of a TLS response.</p>

<p>Oraclize provides the above proof, along with the result, so that you can be 100% sure that we are behaving honestly and that our response is really coming from a certain server at a specific time.</p>

<h2 id="android-proof">Android proof</h2>

<p>In <a href="http://ipfs.io/ipfs/QmWt9AZ3imf5eJsLUCPYmz1tNUD5TuLwMfcQsx8ai7z7Ud" target="_blank">this whitepaper</a>, we present a new experimental proof-of-honesty which uses a physical Android device as a secure environment
for creating successful HTTPS connections. Guarantees of security, as well as the capability to prove this security to a third party, come from the use of SafetyNet Software Attestation and Android Hardware Attestation. SafetyNet provides guarantees that root certificate authorities have not been tampered with, and Android Hardware Attestation provides proof that the private key used to sign the data is hardware-backed, that the device is updated, and that the device&rsquo;s Root-Of-Binding-Trust is valid.</p>

<aside class="notice">
Please note that this authenticity proof is experimental and that the white paper has been published for community review.
</aside>

          <h1 id="ethereum-integration">Ethereum integration</h1>

<p>The following is meant to be a short but complete manual to explain how the interfacing of an Ethereum contract with Oraclize actually works.</p>

<p>All the reference code we will be using next is written in Solidity, but since the interface would be the same for any other language, feel free to use one you like.</p>

<p>Sending a query to Oraclize means sending a transaction to the last Oraclize contract. In order to do that we have to:</p>

<ul>
<li>take care of paying Oraclize the expected amount, which can vary depending on the query we are about to send</li>
<li>and pass the query in the right format.</li>
</ul>

<p>With that, Oraclize will:</p>

<ul>
<li>fetch your result</li>
<li>then send it back to your address, which most of the time will be your own contract address, with a transaction calling a dedicated <code class="prettyprint">__callback</code> method.</li>
</ul>

<p>Note that the transaction sent back by Oraclize can trigger any status change in your contract, and can include the sending of another query to Oraclize. What can be done in the <code class="prettyprint">__callback</code> method is limited by your immagination and, well, the <code class="prettyprint">gasLimit</code>.</p>

<h2 id="getting-everything-on-track">Getting everything on track</h2>

<p><strong>If you are using Solidity:</strong>
First, you need to import our <code class="prettyprint">usingOraclize</code> contract into your code. You do not need to import the <code class="prettyprint">OraclizeI</code> and <code class="prettyprint">OraclizeAddrResolverI</code> contract interfaces as this is taken care of.</p>

<p>The purpose of the <code class="prettyprint">usingOraclize</code> contract is to make calls to <code class="prettyprint">OraclizeI</code> and <code class="prettyprint">OraclizeAddrResolverI</code> as painless as possible for you. However, if you know what you are doing, you are free to call our <code class="prettyprint">OraclizeI</code> and <code class="prettyprint">OraclizeAddrResolverI</code> interfaces directly. The upside is that you would spend a lower amount of gas for contract deployment. The downside is that if anything goes wrong a <code class="prettyprint">throw</code> is raised.</p>

<p>In order to simplify the use of our API, we highly recommend that you simply extend the <code class="prettyprint">usingOraclize</code> contract and use its inherited methods, about which we discuss below. Indeed, these methods already handle payments and API calls correctly.</p>

<p>All the code you need is found here <a href="http://dev.oraclize.it/api.sol" target="_blank">http://dev.oraclize.it/api.sol</a>. After making your contract extend <code class="prettyprint">usingOraclize</code>, it would look like:</p>
<pre class="highlight javascript"><code><span class="cm">/*
import "dev.oraclize.it/api.sol" just works while using 
dev.oraclize.it web IDE, needs to be imported manually otherwise 
*/</span>
<span class="kr">import</span> <span class="s2">"dev.oraclize.it/api.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">YourContractName</span> <span class="nx">is</span> <span class="nx">usingOraclize</span> <span class="p">{</span>

    <span class="kd">function</span> <span class="nx">YourContractName</span><span class="p">(){</span>
        <span class="p">..</span>
    <span class="p">}</span> 

<span class="p">}</span>
</code></pre>

<p><strong>If you are using Serpent:</strong>
You just need to import the oraclize API via <code class="prettyprint">inset()</code> command, you can find all the code you need to import here <a href="http://dev.oraclize.it/api.se" target="_blank">http://dev.oraclize.it/api.se</a></p>
<pre class="highlight python"><code><span class="c"># In serpent you just need to import (inset)</span>
<span class="c"># the oraclize API inside your contract</span>

<span class="n">inset</span><span class="p">(</span><span class="s">"oraclizeAPI.se"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
    <span class="o">..</span>

</code></pre>

<h2 id="network-selection">Network selection</h2>

<p>Oraclize is available both on the public Ethereum mainnet and on the Morden testnet.</p>

<p>There is no need anymore to manually specify the network your contract will be deployed to: the helper functions will figure it out automagically.</p>

<p>If you are looking for an Oraclize integration with your private blockchain please <a href="mailto:info@oraclize.it" target="_blank">get in touch with us</a> to know more about the options we provide.</p>

<h2 id="simple-query">Simple query</h2>

<blockquote>
<p><strong>Note:</strong>
All the code written here assumes that you have already included all the necessary code as described in the paragraphs above, and that your contract already extends our <code class="prettyprint">usingOraclize</code> contract (if you are using Solidity).</p>
</blockquote>

<p>When sending a query to Oraclize you have to specify at least two arguments:</p>

<ul>
<li>The data-source you want to fetch the data from. Supported values are <code class="prettyprint">URL</code>, <code class="prettyprint">WolframAlpha</code>, <code class="prettyprint">Blockchain</code>, <code class="prettyprint">IPFS</code></li>
<li>The argument for the given data-source:

<ul>
<li>the full <code class="prettyprint">URL</code>, which might use our JSON / XML parsing helpers</li>
<li>or the <code class="prettyprint">WolframAlpha</code> formula</li>
<li>or the <code class="prettyprint">Blockchain</code>-provided syntax</li>
<li>or the <code class="prettyprint">IPFS</code> multihash</li>
</ul></li>
</ul>

<p>More information about these can be found in the <a href="#overview">Overview</a> document.</p>

<p>An example code might look like this:</p>
<pre class="highlight javascript"><code><span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"WolframAlpha"</span><span class="p">,</span> <span class="s2">"random number between 0 and 100"</span><span class="p">);</span>
</code></pre>
<pre class="highlight python"><code><span class="n">oraclize_query</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s">"WolframAlpha"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"random number between 0 and 100"</span><span class="p">))</span>
</code></pre>

<p>This code example will ask Oraclize to send you back immediately a transaction with the primary result (as a string) of the given formula (&ldquo;random number between 0 and 100&rdquo;) fetched from the data-source &ldquo;WolframAlpha&rdquo;.</p>

<p>Similarly, you can use any other data-source, here we list some examples:</p>
<pre class="highlight javascript"><code><span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"api.kraken.com/0/public/Ticker?pair=ETHXBT"</span><span class="p">);</span>
</code></pre>
<pre class="highlight python"><code><span class="n">oraclize_query</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s">"URL"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"api.kraken.com/0/public/Ticker?pair=ETHXBT"</span><span class="p">))</span>
</code></pre>
<pre class="highlight javascript"><code><span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://www.therocktrading.com/api/ticker/BTCEUR).result.0.last"</span><span class="p">);</span>
</code></pre>
<pre class="highlight python"><code><span class="n">oraclize_query</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s">"URL"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"json(https://www.therocktrading.com/api/ticker/BTCEUR).result.0.last"</span><span class="p">))</span>
</code></pre>
<pre class="highlight javascript"><code><span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"IPFS"</span><span class="p">,</span> <span class="s2">"QmdEJwJG1T9rzHvBD8i69HHuJaRgXRKEQCP7Bh1BVttZbU"</span><span class="p">);</span>
</code></pre>
<pre class="highlight python"><code><span class="n">oraclize_query</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s">"IPFS"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"QmdEJwJG1T9rzHvBD8i69HHuJaRgXRKEQCP7Bh1BVttZbU"</span><span class="p">))</span>
</code></pre>
<pre class="highlight javascript"><code><span class="cm">/* 
  the only data-source accepting 2 string arguments is
  'URL' when we want it to send an HTTP POST request
  with the 2nd argument being the query-string we want
  to send to the given server.

  note that when the 2nd argument is a valid JSON string it will be automatically sent as JSON
*/</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://shapeshift.io/sendamount).success.deposit"</span><span class="p">,</span> <span class="s1">'{"pair": "eth_btc", "amount": "1", "withdrawal": "1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}'</span><span class="p">);</span>
</code></pre>
<pre class="highlight python"><code><span class="c"># the only data-source accepting 2 string arguments is</span>
<span class="c"># 'URL' when we want it to send an HTTP POST request</span>
<span class="c"># with the 2nd argument being the query-string we want</span>
<span class="c"># to send to the given server.</span>

<span class="c"># note that when the 2nd argument is a valid escaped JSON string it will be automatically sent as JSON</span>
<span class="c">#      in serpent you must escape the JSON object</span>

<span class="n">oraclize_query</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s">"URL"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"json(https://shapeshift.io/sendamount).success.deposit"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"{</span><span class="se">\"</span><span class="s">pair</span><span class="se">\"</span><span class="s">: </span><span class="se">\"</span><span class="s">eth_btc</span><span class="se">\"</span><span class="s">, </span><span class="se">\"</span><span class="s">amount</span><span class="se">\"</span><span class="s">: </span><span class="se">\"</span><span class="s">1</span><span class="se">\"</span><span class="s">, </span><span class="se">\"</span><span class="s">withdrawal</span><span class="se">\"</span><span class="s">: </span><span class="se">\"</span><span class="s">1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5</span><span class="se">\"</span><span class="s">}"</span><span class="p">))</span>
</code></pre>

<h2 id="schedule-a-query-in-the-future">Schedule a query in the future</h2>

<p>If you want Oraclize to execute your query at a scheduled future time, just specify the delay (in seconds) from the current time or the timestamp in the future as first argument.</p>

<p>Please note that in order for the future timestamp to be accepted by Oraclize it must be within 60 days from the current time.</p>
<pre class="highlight javascript"><code><span class="c1">// get the result from the given URL 60 seconds from now</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">);</span>
</code></pre>
<pre class="highlight python"><code><span class="c"># get the result from the given URL 60 seconds from now</span>
<span class="n">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">text</span><span class="p">(</span><span class="s">"URL"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">))</span>
</code></pre>
<pre class="highlight javascript"><code><span class="c1">// get the result from the given datasource at the specified timestamp in the future</span>
<span class="nx">oraclize_query</span><span class="p">(</span><span class="nx">scheduled_arrivaltime</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">3600</span><span class="p">,</span> <span class="s2">"WolframAlpha"</span><span class="p">,</span> <span class="nx">strConcat</span><span class="p">(</span><span class="s2">"flight "</span><span class="p">,</span> <span class="nx">flight_number</span><span class="p">,</span> <span class="s2">" landed"</span><span class="p">));</span>
</code></pre>
<pre class="highlight python"><code><span class="c"># get the result from the given datasource at the specified timestamp in the future</span>
<span class="n">oraclize_query</span><span class="p">(</span><span class="n">scheduled_arrivaltime</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">3600</span><span class="p">,</span> <span class="n">text</span><span class="p">(</span><span class="s">"WolframAlpha"</span><span class="p">),</span> <span class="n">strConcat</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s">"flight "</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="n">flight_number</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">" landed"</span><span class="p">)))</span>
</code></pre>

<h2 id="the-query-id">The query ID</h2>

<p>Every time you call <code class="prettyprint">oraclize_query(...)</code>, it returns you a unique ID that represents your query. Whether you store this ID for future reference is up to you.</p>
<pre class="highlight javascript"><code><span class="c1">// get the result from the given URL 60 seconds from now</span>
<span class="nx">bytes32</span> <span class="nx">myid</span> <span class="o">=</span> <span class="nx">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">);</span>
</code></pre>
<pre class="highlight python"><code><span class="c"># get the result from the given URL 60 seconds from now</span>
<span class="n">data</span> <span class="n">myid</span>

<span class="bp">self</span><span class="o">.</span><span class="n">myid</span> <span class="o">=</span> <span class="n">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">text</span><span class="p">(</span><span class="s">"URL"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">));</span>
</code></pre>

<h2 id="callback-functions">Callback functions</h2>

<p>Once your result is ready, Oraclize will send a transaction back to your contract address, and invoke 1 of these 3 methods:</p>

<ul>
<li>either <code class="prettyprint">__callback(bytes32 myid, string result)</code></li>
<li>or, <strong>if you requested for the TLS Notary proof, <code class="prettyprint">__callback(bytes32 myid, string result, bytes proof)</code></strong></li>
<li>or, as a last resort, if the other methods are absent, the fallback function <code class="prettyprint">function()</code></li>
</ul>

<p>Here are some handling examples:</p>
<pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">oraclize_cbAddress</span><span class="p">())</span> <span class="k">throw</span><span class="p">;</span> <span class="c1">// just to be sure the calling address is the Oraclize authorized one</span>
    <span class="nx">ETHXBT</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span> <span class="c1">// doing something with the result..</span>
    <span class="nx">bytes32</span> <span class="nx">myid</span> <span class="o">=</span> <span class="nx">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">);</span> <span class="c1">// new query for Oraclize!</span>
<span class="p">}</span>
</code></pre>
<pre class="highlight python"><code><span class="n">data</span> <span class="n">myid</span>

<span class="k">def</span> <span class="nf">__callback</span><span class="p">(</span><span class="n">myid</span><span class="p">:</span><span class="n">bytes32</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span><span class="n">string</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">sender</span> <span class="o">!=</span> <span class="n">oraclize_cbAddress</span><span class="p">()):</span>
        <span class="k">return</span> <span class="c"># just to be sure the calling address is the Oraclize authorized one</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ETHXBT</span> <span class="o">=</span> <span class="n">result</span> <span class="c"># doing something with the result..</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">myid</span> <span class="o">=</span> <span class="n">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">text</span><span class="p">(</span><span class="s">"URL"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">))</span> <span class="c"># new query for Oraclize!</span>
</code></pre>

<p>In the snippet above we call <code class="prettyprint">oraclize_query</code> again within the <code class="prettyprint">__callback</code> function. In effect, this makes the contract receive automatically <code class="prettyprint">__callback</code> every minute forever. Or at least, until you run out of funds!</p>

<p>Note that <code class="prettyprint">myid</code> can be used to implement different behaviours into the <code class="prettyprint">__callback</code> function, in particular when there is more than one pending call from Oraclize.</p>

<h2 id="custom-gas">Custom gas</h2>

<p>The transaction originating from Oraclize to your <code class="prettyprint">__callback</code> function costs gas, just like any other transaction. However, as you learned earlier, you need to cover Oraclize for this gas cost, and the <code class="prettyprint">oraclize_query</code> function helpfully handles that. It defaults at 200,000 gas.</p>

<p>This <em>return</em> gas cost is actually in your control since you write the code in the <code class="prettyprint">__callback</code> method, and as such, can estimate it. So, when placing a query with Oraclize, you can also specify how much the <code class="prettyprint">gasLimit</code> should be on the <code class="prettyprint">__callback</code> transaction. Note however that, since  Oraclize sends the transaction, any unspent gas is returned to Oraclize, not you.</p>

<p>If the default, and minimum, value of 200,000 gas,  is not enough, you can increase it by specifying a different <code class="prettyprint">gasLimit</code> in this way:</p>
<pre class="highlight javascript"><code><span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"WolframAlpha"</span><span class="p">,</span> <span class="s2">"random number between 0 and 100"</span><span class="p">,</span> <span class="mi">500000</span><span class="p">);</span> <span class="c1">// Oraclize will use a 500k gasLimit for the callback transaction, instead of 200k</span>
</code></pre>
<pre class="highlight python"><code><span class="n">oraclize_query</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s">"WolframAlpha"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"random number between 0 and 100"</span><span class="p">),</span> <span class="mi">500000</span><span class="p">)</span> <span class="c"># Oraclize will use a 500k gasLimit for the callback transaction, instead of 200k</span>
</code></pre>
<pre class="highlight javascript"><code><span class="nx">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"WolframAlpha"</span><span class="p">,</span> <span class="s2">"random number between 0 and 100"</span><span class="p">,</span> <span class="mi">500000</span><span class="p">);</span> <span class="c1">// you can set both custom timestamp/delay and custom gasLimit</span>
</code></pre>
<pre class="highlight python"><code><span class="n">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">text</span><span class="p">(</span><span class="s">"WolframAlpha"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"random number between 0 and 100"</span><span class="p">),</span> <span class="mi">500000</span><span class="p">)</span> <span class="c"># you can set both custom timestamp/delay and custom gasLimit</span>
</code></pre>

<p>Note also that if you offer too low a <code class="prettyprint">gasLimit</code>, and your <code class="prettyprint">__callback</code> method is long, you may never see a callback.</p>

<h2 id="tlsnotary-proof">TLSNotary proof</h2>

<p>In order to get, or not, the TLSNotary proof back from Oraclize you need to specify the <code class="prettyprint">proofType</code> and <code class="prettyprint">proofStorage</code>. You do this by calling: </p>

<ul>
<li>either <code class="prettyprint">oraclize_setProof(proofType_NONE)</code></li>
<li>or <code class="prettyprint">oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS)</code> </li>
</ul>

<p>You may execute this method just once, for instance in the constructor, or at any other time, if, for instance, you need the proof for certain queries only. </p>

<ul>
<li><code class="prettyprint">proofType_NONE</code> is the default setting</li>
<li><code class="prettyprint">proofType_IPFS</code> is the only method of storage supported, at the time of writing, for the TLSNotary proof.</li>
</ul>

<p><code class="prettyprint">proofStorage_IPFS</code> means that Oraclize will:</p>

<ul>
<li>use <a href="http://ipfs.io/" target="_blank">IPFS</a> to store your complete TLSNotary proof</li>
<li>and will call back your contract on the <code class="prettyprint">__callback(bytes32 myid, string result, bytes proof)</code> function <strong>instead of the default</strong> <code class="prettyprint">__callback(bytes32 myid, string result)</code></li>
</ul>

<p>The <code class="prettyprint">proof</code> string is exactly the IPFS multihash that identifies your TLSNotary proof, so you can fetch it for example at http://ipfs.io/ipfs/<code class="prettyprint">proof</code></p>

<blockquote>
<p><strong>Note:</strong>
There might not always be a TLSNotary proof for your query, depending on the data source you have chosen</p>
</blockquote>

<p>Here is an example:</p>
<pre class="highlight javascript"><code><span class="cm">/*
import "dev.oraclize.it/api.sol" just works while using 
dev.oraclize.it web IDE, needs to be imported manually otherwise 
*/</span>
<span class="kr">import</span> <span class="s2">"dev.oraclize.it/api.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">YourContractName</span> <span class="nx">is</span> <span class="nx">usingOraclize</span> <span class="p">{</span>

    <span class="kd">function</span> <span class="nx">YourContractName</span><span class="p">(){</span>
        <span class="nx">oraclize_setProof</span><span class="p">(</span><span class="nx">proofType_TLSNotary</span> <span class="o">|</span> <span class="nx">proofStorage_IPFS</span><span class="p">);</span>
        <span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"xml(https://www.fueleconomy.gov/ws/rest/fuelprices).fuelPrices.diesel"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">bytes</span> <span class="nx">proof</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">oraclize_cbAddress</span><span class="p">())</span> <span class="k">throw</span><span class="p">;</span>
        <span class="p">..</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<pre class="highlight python"><code><span class="c"># In serpent you just need to import (inset)</span>
<span class="c"># the oraclize API inside your contract</span>

<span class="n">inset</span><span class="p">(</span><span class="s">"oraclizeAPI.se"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
    <span class="n">oraclize_setProof</span><span class="p">(</span><span class="n">proofType_TLSNotary</span> <span class="o">|</span> <span class="n">proofStorage_IPFS</span><span class="p">)</span>
    <span class="n">oraclize_query</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s">"URL"</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">"xml(https://www.fueleconomy.gov/ws/rest/fuelprices).fuelPrices.diesel"</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">__callback</span><span class="p">(</span><span class="n">myid</span><span class="p">:</span><span class="n">bytes32</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span><span class="n">string</span><span class="p">,</span> <span class="n">proof</span><span class="p">:</span><span class="nb">bytes</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">sender</span> <span class="o">!=</span> <span class="n">oraclize_cbAddress</span><span class="p">()):</span>
        <span class="k">return</span>
    <span class="o">..</span>
</code></pre>

<h2 id="more-examples">More examples</h2>

<p>You can have a look at more complete and complex examples by heading to our dedicated github repository: <a href="https://github.com/oraclize/ethereum-examples" target="_blank">https://github.com/oraclize/ethereum-examples</a></p>

<h2 id="random-utilities">Random utilities</h2>

<p>Since the callback transaction always provides results as strings, the Solidity API helpers also include some convenience functions, which might prove useful to you. Especially since Solidity does not provide any official &ldquo;standard Library&rdquo; yet.</p>

<p>You can check them out <a href="https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI.sol#L124" target="_blank">here</a>.</p>

<h2 id="best-practices">Best practices</h2>
<pre class="highlight javascript"><code><span class="cm">/*
import "dev.oraclize.it/api.sol" just works while using 
dev.oraclize.it web IDE, needs to be imported manually otherwise 
*/</span>
<span class="kr">import</span> <span class="s2">"dev.oraclize.it/api.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">YourContractName</span> <span class="nx">is</span> <span class="nx">usingOraclize</span> <span class="p">{</span>

    <span class="nx">mapping</span><span class="p">(</span><span class="nx">bytes32</span><span class="o">=&gt;</span><span class="nx">bool</span><span class="p">)</span> <span class="nx">myidList</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">YourContractName</span><span class="p">(){</span>
         <span class="nx">oraclize_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span><span class="s2">"json(http://exampleUrl.url).result"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">oraclize_cbAddress</span><span class="p">())</span> <span class="k">throw</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">myidList</span><span class="p">[</span><span class="nx">myid</span><span class="p">]</span><span class="o">==</span><span class="kc">true</span><span class="p">)</span> <span class="k">throw</span><span class="p">;</span> <span class="c1">// check if this myid was already processed before</span>
        <span class="nx">myidList</span><span class="p">[</span><span class="nx">myid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// mark this myid (default bool value is false)</span>
        <span class="p">...</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre>

<p>What follows are some practical tips we recommend you to use when writing Oraclize-based smart contracts:</p>

<ul>
<li><p>when integrating the Oraclize service into your smart contract it&rsquo;s better to use our <a href="https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI.sol" target="_blank">API helpers</a> instead of interfacing with the connector directly as the connector address may be updated.</p></li>
<li><p>the <code class="prettyprint">myid</code> returned by Oraclize in the <code class="prettyprint">__callback</code> function should always be checked by your smart contract. Specifically, the smart contract should verify that the <code class="prettyprint">myid</code> is unique and consequently mark it. This ensures each query response is processed only once and helps to avoid misuses of your contract logic.</p></li>
</ul>

          <h1 id="pricing">Pricing</h1>

<p>The use of Oraclize APIs requires the payment of a small fee, you can check out the pricing for each integration below:</p>

<ul>
<li><a href="#pricing-ethereum">Ethereum</a></li>
</ul>

<h2 id="ethereum">Ethereum</h2>

<p>The fee for Ethereum comes on top of the reimbursement for the full <code class="prettyprint">gasLimit</code> we are setting in the transaction when we call back your contract.</p>

<h3 id="free-calls">Free calls</h3>

<p>In order to make the testing of our service a little bit easier (and cheaper) to you, <strong>the first Oraclize query call coming from any Ethereum address is completely free of charge</strong>. This means we are even covering the callback transaction gas costs for you (up to the default <code class="prettyprint">gasLimit</code> of 200k gas).</p>

<p>This might be helpful, for example, to send the first call to Oraclize directly from your contract constructor function without having to create your contract with an attached amount of Wei. This means, again, that you can have one free triggering transaction for any date in the future (up to 60 days).</p>

<aside class="notice">
Note: Oraclize calls are free when used on testnets! This works for moderate usage in test environments only.
</aside>

<h3 id="call-fees">Call fees</h3>

<p>Payment is part and parcel of the <code class="prettyprint">oraclize_query</code> function call, and our pricing model is simple. It&rsquo;s composed of two parts:</p>

<ul>
<li>a price in $ depending on the datasource used and the proof chosen (see table below). This $ price is automatically converted to Ether at the current rate when you call <code class="prettyprint">oraclize_query</code></li>
<li>a refund of the full <code class="prettyprint">gasLimit</code> we are setting in the callback transaction (the minimum and default value is 200k gas)</li>
</ul>

<style type="text/css">
    tr, td, th {
        text-align: center !important;
        vertical-align: middle !important;
    }
</style>

<table>
  <tr>
    <th rowspan="2" style="vertical-align: bottom !important;">Datasource</th>
    <th rowspan="2" style="vertical-align: bottom !important;">Base price</th>
    <th colspan="2">Proof type</th>
  </tr>
  <tr>
    <td>None</td>
    <td>TLSNotary</td>
  </tr>
  <tr>
    <td>URL</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.01$</td>
    <td>+0.0$</td>
    <td>+0.04$</td>
  </tr>
  <tr>
    <td>Blockchain</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.01$</td>
    <td>+0.0$</td>
    <td>+0.04$</td>
  </tr>
  <tr>
    <td>WolframAlpha</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.03$</td>
    <td>+0.0$</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>IPFS</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.01$</td>
    <td>+0.0$</td>
    <td>N/A</td>
  </tr>
</table>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="javascript">Solidity</a>
                <a href="#" data-language-name="python">Serpent</a>
          </div>
      </div>
    </div>
    <script>
    $.get('lastupdate.txt', function(date){
	$('#lastupdate').html('Last update: '+date.trim());
    }, 'text');

    $('a[href^="#"]').on('click',function(e){
      e.preventDefault();
      var href = $(this).attr('href');
      if(typeof(href)=='undefined') return;
      if(href.indexOf('-')!==-1) scrollToSection(href);
      else location.hash = href;
    });

    function scrollToSection(href){
      $('html,body').animate({
        scrollTop: $('div[data-unique='+href.substr(1)+']').offset().top+60,
      },0);
    }
    </script>
  </body>
</html>
